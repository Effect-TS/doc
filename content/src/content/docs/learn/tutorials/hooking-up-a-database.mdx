---
type: Tutorial
title: Hooking up a database
tags:
  - some
  - tags
sidebar:
  order: 3
---

The next endpoint we're going to migrate is one that lists all of the users in a
database. For this tutorial I'm going to use Postgres running in Docker as our
database. If you don't have Docker installed, I recommend following the
[official getting started guide](https://www.docker.com/get-started/).

When you're ready, you can start a Postgres container with:

```shell
docker run -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 postgres
```

## Creating our data

To create our `users` table and sample data, we're going to use the `psql`
tool that's present inside of the Docker container we created. Open a new
terminal and run:

```shell
docker exec -it $(docker ps -qf ancestor=postgres) psql -U postgres
```

This will drop you into a `psql` shell, with a prompt that starts `postgres=#`.
From here you can run the following SQL commands:

```sql
CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT);
INSERT INTO users (name) VALUES ('Alice');
INSERT INTO users (name) VALUES ('Bob');
```

## The `/users` endpoint

Let's take a look at our app in full with new Express.js `/users` endpoint added
to it:

```ts twoslash {6,8-12,16-19,30} title=index.ts
import express from "express";

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node";
import { HttpRouter, HttpServerResponse } from "@effect/platform";
import { Effect } from "effect";
import { Client } from "pg";

const db = new Client({
  host: "localhost",
  user: "postgres",
  password: "mysecretpassword",
});

const app = express();

app.get("/users", async (req, res) => {
  const { rows } = await db.query("SELECT * FROM users");
  res.send({ users: rows });
});

function health() {
  return HttpServerResponse.text("ok");
}

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", Effect.sync(health))
);

const main = Effect.gen(function* () {
  yield* Effect.promise(() => db.connect());
  app.use(yield* NodeHttpServer.makeHandler(router));
  app.listen(3000);
  yield* Effect.never;
});

NodeRuntime.runMain(main);
```

We'll also need to add some new dependencies to our project:

```shell
bun add pg @types/pg
```

Then you can run the server with:

```shell
bun index.ts
```

And in another shell we can test the endpoint.

```shell
http get localhost:3000/users
```

```http
HTTP/1.1 200 OK
Content-Length: 57
Content-Type: application/json; charset=utf-8
Date: Fri, 14 Feb 2025 14:28:02 GMT
ETag: W/"39-6Qu85qIU12mhgGYWwHErQVfJRxI"
X-Powered-By: Express

{
    "users": [
        {
            "id": 1,
            "name": "Alice"
        },
        {
            "id": 2,
            "name": "Bob"
        }
    ]
}
```

## The direct approach

If we were to copy what we did with the `/health` endpoint, we'd end up with
code that looked like this:

```ts twoslash
import { HttpRouter, HttpServer, HttpServerResponse } from "@effect/platform"
import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({
  host: "localhost",
  user: "postgres",
  password: "mysecretpassword",
});
const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
//---cut---
// @errors: 2379
const users = Effect.promise(async () => {
  const { rows } = await db.query("SELECT * FROM users");
  return HttpServerResponse.json({ users: rows });
});

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health),
  HttpRouter.get("/users", users),
)
```

This doesn't work, as we can see from the error. The reason is that
`HttpServerResponse.json` is an operation that might fail. Not all JavaScript
objects can be converted to JSON.

```ts twoslash
JSON.stringify({ big: 10n })
//=> TypeError: JSON.stringify cannot serialize BigInt.
```

For this reason, `HttpServerResponse.json` returns an `Effect` that can fail.
We didn't see this earlier because `HttpServerResponse.text` can't fail, and
so just returns an `HttpServerResponse` directly.

## Error handling in Effect

When we introduced the `Effect` type in the previous section, we dealt
exclusively with Effects that couldn't fail. That won't get us very far if
we're building anything non-trivial.

`Effect` is a generic type that takes 3 arguments:

```typescript
Effect<Success, Error, Requirements>
```

`Success` is the type the Effect returns when it succeeds, `Error` is the type
it returns when it fails, and we'll talk about `Requirements` a bit later.

When we created our example Effects in the previous section, these all took on
the type `Effect<string, never, never>`.

```ts twoslash
import { Effect } from "effect"
//---cut---
Effect.sync(() => "Hello, world!")
//=> Effect.Effect<string, never, never>
```

This means they will return a `string` on success, and never fail.

The Effect that `HttpServerResponse.json` returns is of type
`Effect<HttpServerResponse, HttpBodyError, never>`. So when we try to return
it from our `users` handler, we end up wrapping one Effect in another.

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({
  host: "localhost",
  user: "postgres",
  password: "mysecretpassword",
});
//---cut---
const users = Effect.promise(async () => {
//    ^?
  const { rows } = await db.query("SELECT * FROM users");
  return HttpServerResponse.json({ users: rows });
});
```

This is what the type error from earlier was trying to tell us. Here's the
error again:

```text wrap
Argument of type 'Effect<Effect<HttpServerResponse, HttpBodyError, never>, never, never>' is not assignable to parameter of type 'Handler<never, never>'
```

Under the hood, a `Handler<never, never>` is an `Effect<HttpServerResponse,
never, never>`. Because `Effect<HttpServerResponse, HttpBodyError, never>` is
not an `HttpServerResponse`, the type checker gets upset with us.

## Fixing our nested Effects with `flatMap`

It's possible to fix this with a call to `Effect.flatMap`:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({
  host: "localhost",
  user: "postgres",
  password: "mysecretpassword",
});
//---cut---
const users = Effect.flatMap(
  Effect.promise(async () => {
    const { rows } = await db.query("SELECT * FROM users");
    return { users: rows };
  }),
  HttpServerResponse.json
);
```

But it is more idiomatic in Effect to use `pipe`:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({
  host: "localhost",
  user: "postgres",
  password: "mysecretpassword",
});
//---cut---
const users = Effect.promise(
  () => db.query("SELECT * FROM users")
).pipe(
  Effect.map(({ rows }) => ({ users: rows })),
  Effect.flatMap(HttpServerResponse.json)
);
```

This no longer gives us a type error. We've split our computation into parts:
fetching the data with `Effect.promise`, manipulating its shape with
`Effect.map`, and serializing it with `HttpServerResponse.json`. The
`Effect.flatMap` at the end care of the accidental `Effect` nesting.

## An aside on pipes

If `pipe` isn't quite clicking for you yet, one way to visualise it is that
you're passing some data through a sequence of functions.

Take this example:

```ts twoslash
import { pipe } from "effect"

const add = (x: number) => (y: number) => y + x
const mul = (x: number) => (y: number) => y * x
const sub = (x: number) => (y: number) => y - x

const result = pipe(
  1,
  add(2),
  mul(3),
  sub(1)
)
console.log(result)
//=> 8
```

`add`, `mul`, and `sub` are all functions that return functions. So `add(2)`
returns a function that can add 2 to a given number: `add(2)(1)` returns 3.
Our pipeline starts with 1, then passes it through `add(2)`, `mul(3)`, and
`sub(1)`, resulting in 8.

One of the powers this gives you is the ability to add things easily into
the pipeline.

```ts twoslash {6-9,14,16,18}
import { pipe } from "effect"

const add = (x: number) => (y: number) => y + x
const mul = (x: number) => (y: number) => y * x
const sub = (x: number) => (y: number) => y - x
const log = (s: string) => (y: number) => {
  console.log(s, y)
  return y
}

const result = pipe(
  1,
  add(2),
  log("1 + 2 ="),
  mul(3),
  log("  * 3 ="),
  sub(1),
  log("  - 1 ="),
)
```

This prints the following, with `result` still being 8:

```
1 + 2 = 3
  * 3 = 9
  - 1 = 8
```

As we migrate more complex endpoints, we'll see how this ability to "tap into"
the pipeline is really useful.

## Adding error handling to our database query

All this talk of error handling might have gotten you thinking: can't our
database query fail? It can! If the database file doesn't exist, or the query
is malformed, the `db.prepare` call will throw an error. When that happens,
at the moment our endpoint will return a 500 error to the client.

```shell
$ mv sqlite.db sqlite.db.bak
$ http get "localhost:3000/users"
HTTP/1.1 500 Internal Server Error
Content-Length: 0
Date: Fri, 07 Feb 2025 11:29:30 GMT
X-Powered-By: Express
```

Strictly speaking, a 500 error is correct here. Our server encountered an error
because of a server-side problem, which is what the 500-class errors are for.
But it's not good Effect to let exceptions bubble up like this.

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"

import { Database, SQLiteError } from "bun:sqlite"
const db = new Database("sqlite.db")
//---cut---
const users = Effect.suspend(() => {
  try {
    return Effect.succeed({
      users: db.prepare("SELECT * FROM users").all(),
    });
  } catch (e) {
    if (e instanceof SQLiteError) {
      return Effect.fail(e);
    }
    return Effect.die(e);
  }
}).pipe(Effect.flatMap(HttpServerResponse.json));
```

We've made a lot of changes here, let's go through them one at a time.

1.  We're using `Effect.suspend` instead of `Effect.sync`. This is because
   `Effect.sync` is not allowed to fail. If it does, it's treated as what Effect
   calls a "defect", which are a special category of error that represent a bug
   in your program. You can read more about them
   [here](https://effect.website/docs/error-management/unexpected-errors/).
2. Where `Effect.sync` allowed us to return a value directly, `Effect.suspend`
   wants us to return an `Effect`. That's why we're using `Effect.succeed` to
   wrap our users object, and `Effect.fail` to wrap our caught exception.
3. We use `Effect.die` to signal a defect explicitly. Because the only type
   of exception thrown by `db.prepare` is an `SQLiteError`, any other exception
   is unexpected and likely a bug.

What we get in return for all of these changes it **type safety**. We have told
Effect that our database query can fail, and that information is now encoded
into the type of our `users` handler.

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"

import { Database, SQLiteError } from "bun:sqlite"
const db = new Database("sqlite.db")
//---cut---
const users = Effect.suspend(() => {
//    ^?
  try {
    return Effect.succeed({
      users: db.prepare("SELECT * FROM users").all(),
    });
  } catch (e) {
    if (e instanceof SQLiteError) {
      return Effect.fail(e);
    }
    return Effect.die(e);
  }
}).pipe(Effect.flatMap(HttpServerResponse.json));
```

This is one of the most powerful features of Effect: type safe error handling.
To know that Bun's SQLite connector can only throw an `SQLiteError`, I had to
read the source code. But with our `users` handler, that information is not
only available to us as developers, but to the type checker as well.