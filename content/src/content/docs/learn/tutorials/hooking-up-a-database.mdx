---
type: Tutorial
title: Hooking up a database
tags:
  - some
  - tags
sidebar:
  order: 3
---

The next endpoint we're going to migrate is one that lists all of the users in a
database. For this tutorial I'm going to use Postgres running in Docker as our
database. If you don't have Docker installed, I recommend following the
[official getting started guide](https://www.docker.com/get-started/).

When you're ready, you can start a Postgres container with:

```shell
docker run -e POSTGRES_HOST_AUTH_METHOD=trust -p 5432:5432 postgres
```

## Creating our data

To create our `users` table and sample data, we're going to use the `psql`
tool that's present inside of the Docker container we created. Open a new
terminal and run:

```shell
docker exec -it $(docker ps -qf ancestor=postgres) psql -U postgres
```

This will drop you into a `psql` shell, with a prompt that starts `postgres=#`.
From here you can run the following SQL commands:

```sql
CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT);
INSERT INTO users (name) VALUES ('Alice');
INSERT INTO users (name) VALUES ('Bob');
```

## The `/users` endpoint

Let's take a look at our app in full with new Express.js `/users` endpoint added
to it:

```ts twoslash {6,8,11-14,25} title=index.ts
import express from "express";

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node";
import { HttpRouter, HttpServerResponse } from "@effect/platform";
import { Effect } from "effect";
import { Client } from "pg";

const db = new Client({ user: "postgres" });
const app = express();

app.get("/users", async (req, res) => {
  const { rows } = await db.query("SELECT * FROM users");
  res.send({ users: rows });
});

function health() {
  return HttpServerResponse.text("ok");
}

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", Effect.sync(health))
);

const main = Effect.gen(function* () {
  yield* Effect.promise(() => db.connect());
  app.use(yield* NodeHttpServer.makeHandler(router));
  app.listen(3000);
  yield* Effect.never;
});

NodeRuntime.runMain(main);
```

We'll also need to add some new dependencies to our project:

```shell
bun add pg @types/pg
```

Then you can run the server with:

```shell
bun index.ts
```

And in another shell we can test the endpoint.

```shell
http get localhost:3000/users
```

```http
HTTP/1.1 200 OK
Content-Length: 57
Content-Type: application/json; charset=utf-8
Date: Fri, 14 Feb 2025 14:28:02 GMT
ETag: W/"39-6Qu85qIU12mhgGYWwHErQVfJRxI"
X-Powered-By: Express

{
    "users": [
        {
            "id": 1,
            "name": "Alice"
        },
        {
            "id": 2,
            "name": "Bob"
        }
    ]
}
```

## The direct approach

If we were to copy what we did with the `/health` endpoint, we'd end up with
code that looked like this:

```ts twoslash
import { HttpRouter, HttpServer, HttpServerResponse } from "@effect/platform"
import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({ user: "postgres" });
const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
//---cut---
// @errors: 2379
const users = Effect.promise(async () => {
  const { rows } = await db.query("SELECT * FROM users");
  return HttpServerResponse.json({ users: rows });
});

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health),
  HttpRouter.get("/users", users),
)
```

This doesn't work, as we can see from the error. The reason is that
`HttpServerResponse.json` is an operation that might fail. Not all JavaScript
objects can be converted to JSON.

```ts twoslash
JSON.stringify({ big: 10n })
//=> TypeError: JSON.stringify cannot serialize BigInt.
```

For this reason, `HttpServerResponse.json` returns an `Effect` that can fail.
We didn't see this earlier because `HttpServerResponse.text` can't fail, and
so just returns an `HttpServerResponse` directly.

## Error handling in Effect

When we introduced the `Effect` type in the previous section, we dealt
exclusively with Effects that couldn't fail. That won't get us very far if
we're building anything non-trivial.

`Effect` is a generic type that takes 3 arguments:

```typescript
Effect<Success, Error, Requirements>
```

`Success` is the type the Effect returns when it succeeds, `Error` is the type
it returns when it fails, and we'll talk about `Requirements` a bit later.

When we created our example Effects in the previous section, these all took on
the type `Effect<string, never, never>`.

```ts twoslash
import { Effect } from "effect"
//---cut---
const _ = Effect.sync(() => "Hello, world!")
//        ^?
```

This means they will return a `string` on success, and never fail.

The Effect that `HttpServerResponse.json` returns is of type
`Effect<HttpServerResponse, HttpBodyError, never>`. So when we try to return
it from our `users` handler, we end up wrapping one Effect in another.

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({ user: "postgres" });
//---cut---
const users = Effect.promise(async () => {
//    ^?
  const { rows } = await db.query("SELECT * FROM users");
  return HttpServerResponse.json({ users: rows });
});
```

This is what the type error from earlier was trying to tell us. Here's the
error again:

```text wrap
Argument of type 'Effect<Effect<HttpServerResponse, HttpBodyError, never>, never, never>' is not assignable to parameter of type 'Handler<never, never>'
```

Under the hood, a `Handler<never, never>` is just a type alias for `Effect<HttpServerResponse,
never, never>`. Because `Effect<HttpServerResponse, HttpBodyError, never>` is
not an `HttpServerResponse`, the type checker gets upset with us.

## Fixing our nested Effects with `flatMap`

It's possible to fix this with a call to `Effect.flatMap`:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({ user: "postgres" });
//---cut---
const users = Effect.flatMap(
  Effect.promise(async () => {
    const { rows } = await db.query("SELECT * FROM users");
    return { users: rows };
  }),
  HttpServerResponse.json
);
```

But it is more idiomatic in Effect to use `pipe`:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({ user: "postgres" });
//---cut---
const users = Effect.promise(
  () => db.query("SELECT * FROM users")
).pipe(
  Effect.map(({ rows }) => ({ users: rows })),
  Effect.flatMap(HttpServerResponse.json)
);
```

This no longer gives us a type error. We've split our computation into parts:
fetching the data with `Effect.promise`, manipulating its shape with
`Effect.map`, and serializing it with `HttpServerResponse.json`. The
`Effect.flatMap` at the end takes care of the accidental `Effect` nesting we had in our previous implementation.

## An aside on pipes

If `pipe` isn't quite clicking for you yet, one way to visualise it is that
you're passing some data through a sequence of functions.

Take this example:

```ts twoslash
import { pipe } from "effect"

const add = (x: number) => (y: number) => y + x
const mul = (x: number) => (y: number) => y * x
const sub = (x: number) => (y: number) => y - x

const result = pipe(
  1,
  add(2),
  mul(3),
  sub(1)
)
console.log(result)
//=> 8
```

`add`, `mul`, and `sub` are all functions that return functions. So `add(2)`
returns a function that can add 2 to a given number: `add(2)(1)` returns 3.
Our pipeline starts with 1, then passes it through `add(2)`, `mul(3)`, and
`sub(1)`, resulting in 8.

One of the powers this gives you is the ability to add things easily into
the pipeline.

```ts twoslash {6-9,14,16,18}
import { pipe } from "effect"

const add = (x: number) => (y: number) => y + x
const mul = (x: number) => (y: number) => y * x
const sub = (x: number) => (y: number) => y - x
const log = (s: string) => (y: number) => {
  console.log(s, y)
  return y
}

const result = pipe(
  1,
  add(2),
  log("1 + 2 ="),
  mul(3),
  log("  * 3 ="),
  sub(1),
  log("  - 1 ="),
)
```

This prints the following, with `result` still being 8:

```
1 + 2 = 3
  * 3 = 9
  - 1 = 8
```

As we migrate more complex endpoints, we'll see how this ability to "tap into"
the pipeline is really useful.

## Adding error handling to our database query

All this talk of error handling might have gotten you thinking: can't our
database query fail? It can! If the query is malformed, `db.query` will throw an
error. When that happens, our endpoint will currently return a 500 error to
the client. Change the SQL query to `SELECT * FROM nonexistent` and try it:

```shell
http get "localhost:3000/users"
```

```http
HTTP/1.1 500 Internal Server Error
Content-Length: 0
Date: Fri, 14 Feb 2025 17:25:57 GMT
X-Powered-By: Express
```

Strictly speaking, a 500 error is correct here. Our server encountered an error
because of a server-side problem, which is what the 500-class errors are for.
But it's not good Effect to let exceptions bubble up like this.

A simple thing we can do is changing `Effect.promise` to `Effect.tryPromise`:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({ user: "postgres" });
//---cut---
const users = Effect.tryPromise(
  () => db.query("SELECT * FROM users")
).pipe(
  Effect.map(({ rows }) => ({ users: rows })),
  Effect.flatMap(HttpServerResponse.json)
);
```

This changes the return type from:

```typescript
Effect<HttpServerResponse, HttpBodyError, never>
```

To:

```typescript
Effect<HttpServerResponse, UnknownException | HttpBodyError, never>
```

`Effect.promise` is assumed to always succeed. `Effect.tryPromise` is assumed
to maybe throw an exception, but because TypeScript doesn't give us any way
to know _what_ exception might be thrown, Effect defaults to `UnknownException`.

We can improve on this:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg";
const db = new Client({ user: "postgres" });
//---cut---
const users = Effect.tryPromise({
  try: () => db.query("SELECT * FROM users"),
  catch: (error) => error,
}).pipe(
  Effect.map(({ rows }) => ({ users: rows })),
  Effect.flatMap(HttpServerResponse.json)
);
```
