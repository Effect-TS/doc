---
type: Tutorial
title: Migrating our first endpoint
tags:
  - some
  - tags
sidebar:
  order: 2
---

The first step to migrating our Express.js app to Effect is to add some
boilerplate that will allow us to write Effect endpoints that live alongside
Express.js.

```ts twoslash {3-5,13-21} title=index.ts
import express from "express"

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { HttpRouter } from "@effect/platform"
import { Effect } from "effect"

const app = express()

app.get("/health", (req, res) => {
  res.type("text/plain").send("ok")
})

const router = HttpRouter.empty

const main = Effect.gen(function* () {
  app.use(yield* NodeHttpServer.makeHandler(router))
  app.listen(3000)
  yield* Effect.never
})

NodeRuntime.runMain(main)
```

And we can run the resulting code like so:

```shell
bun add @effect/platform @effect/platform-node
bun index.ts
```

Our Express.js `/health` handler still works as expected, but we've wrapped the
Express.js app in a way that will allow us to define endpoints using Effect
while still responding to our existing endpoints in Express.js.

There's a lot of new things happening at the bottom of our file. What is
`Effect.gen`, what are those `yield*`s doing, what is `Effect.never`. For the
time being we're going to set these questions aside. It looks intimidating now,
but if you stick with this tutorial to the end, it will not only make sense, but
start to become second nature.

## Our new `/health` handler

The Effect equivalent of our Express.js `/health` handler looks like this:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
// ---cut---
function health() {
  return HttpServerResponse.text("ok")
}
```

`HttpServerResponse` is Effect's class for generating HTTP responses, we need to
use it for any responses returned from Effect.

The way we wire this into our Effect `router` is going to look a little bit
strange, but please stay with me:

```ts twoslash
import { HttpServerResponse, HttpRouter } from "@effect/platform"
import { Effect } from "effect"
// ---cut---
function health() {
  return HttpServerResponse.text("ok")
}

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", Effect.sync(health)),
)
```

What on earth are `Effect.sync` and `.pipe`?

## The Effect Type

At the core of Effect is... well, the `Effect`. You can think of an `Effect` as
a lazy computation, similar to a function that hasn't been called yet.

Here's an example of an `Effect` that returns the string `"Hello, world!"`:

```ts twoslash
import { Effect } from "effect"
// ---cut---
Effect.promise(async () => "Hello, world!")
```

`Effect.promise` takes a function that returns a `Promise` and creates an
`Effect` out of it. `Effect.sync` works exactly the same, except it takes a
synchronous function instead of an asynchronous one.

If we want to run this Effect, we can use `Effect.runPromise`:

```ts twoslash
import { Effect } from "effect"
// ---cut---
const effect = Effect.promise(async () => "Hello, world!")
const result = await Effect.runPromise(effect)
console.log(result)
// => "Hello, world!"
```

What if you want to run an Effect that calls another Effect? You can use
`Effect.gen` to do that:

```ts twoslash {2-5,8}
import { Effect } from "effect"
// ---cut---
const effect = Effect.promise(async () => "Hello, world!")
const gen = Effect.gen(function* () {
  const str = yield* effect
  return str.toUpperCase()
})
const result = await Effect.runPromise(gen)
console.log(result)
// => "HELLO, WORLD!"
```

This makes use of JavaScript's [generator functions][1]. You can think of the
`yield*` keyword as being very similar to `await`ing a `Promise`. Under the
hood, all `Effect`s are generators, and `yield*`ing one passes it to the Effect
runtime and waits for the result.

Given that all we want to do above is call `.toUpperCase()` on the result
of `effect`, the scaffolding of `Effect.gen` may feel heavy. Effect gives us
a suite of tools to work with `Effect`s, and one of those tools is `pipe`:

```ts twoslash {2}
import { Effect } from "effect"
// ---cut---
const effect = Effect.promise(async () => "Hello, world!")
const upper = effect.pipe(Effect.map((s) => s.toUpperCase()))
const result = await Effect.runPromise(upper)
console.log(result)
// => "HELLO, WORLD!"
```

`pipe` passes the result of one computation as input to another. Here,
`Effect.map` transforms the result of the first `Effect` with the function
provided.

We can `pipe` as many `Effect`s together as we like:

```ts twoslash {2-7,10}
import { Effect } from "effect"
// ---cut---
const effect = Effect.promise(async () => "Hello, world!")
const upper = effect.pipe(
  Effect.map((s) => s.toUpperCase()),
  Effect.map((s) => s.split("")),
  Effect.map((s) => s.reverse()),
  Effect.map((s) => s.join("")),
)
const result = await Effect.runPromise(upper)
console.log(result)
// => "!DLROW ,OLLEH"
```

This should give us just enough to carry on with migrating our first endpoint
to Effect. As we continue through this tutorial, we'll introduce more and more
things you can do with the `Effect` type.

## Understanding `HttpRouter`

Looking back at our `HttpRouter`, we used `pipe` to add a new endpoint to our
app:

```ts twoslash
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
function health() {
  return HttpServerResponse.text("ok")
}
// ---cut---
const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", Effect.sync(health)),
)
```

`HttpRouter` is a data structure that represents a collection of routes. The
simplest router is one with no routes at all, and Effect exposes that to us as
the `HttpRouter.empty` value. Under the hood, this is itself an `Effect`:

```ts twoslash
import { HttpRouter } from "@effect/platform"
import { Effect } from "effect"
// ---cut---
console.log(Effect.isEffect(HttpRouter.empty))
// => true
```

The helper `HttpRouter.get` takes an `HttpRouter` as an argument and returns a
new `HttpRouter` with the given route added. If we wanted to, we could have done
this much more directly:

```ts twoslash
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
function health() {
  return HttpServerResponse.text("ok")
}
// ---cut---
const router = HttpRouter.get("/health", Effect.sync(health))(HttpRouter.empty)
```

This is exactly the same as the `pipe` version, except that if we wanted to add
multiple routes it gets unwieldy quickly:

```ts twoslash
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
function health() {
  return HttpServerResponse.text("ok")
}
function status() {
  return HttpServerResponse.text("ok")
}
function version() {
  return HttpServerResponse.text("ok")
}
// ---cut---
HttpRouter.get("/health", Effect.sync(health))(
  HttpRouter.get("/status", Effect.sync(status))(
    HttpRouter.get("/version", Effect.sync(version))(
      HttpRouter.empty,
    ),
  ),
)

// vs

HttpRouter.empty.pipe(
  HttpRouter.get("/version", Effect.sync(version)),
  HttpRouter.get("/status", Effect.sync(status)),
  HttpRouter.get("/health", Effect.sync(health)),
)
```

## The end result

Here's the full code of our app with our `/health` endpoint being served by
Effect:

```ts twoslash {9-15}
import express from "express"

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"

const app = express()

function health() {
  return HttpServerResponse.text("ok")
}

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", Effect.sync(health))
)

const main = Effect.gen(function* () {
  app.use(yield* NodeHttpServer.makeHandler(router))
  app.listen(3000)
  yield* Effect.never
})

NodeRuntime.runMain(main)
```

And the output of the endpoint:

```shell
http get localhost:3000/health
```

```http
HTTP/1.1 200 OK
Content-Length: 2
Content-Type: text/plain
Date: Fri, 14 Feb 2025 13:51:39 GMT
X-Powered-By: Express

ok
```

This output has 2 small differences from the Express.js version:

1. The `Content-Type` header is `text/plain` instead of `text/plain; charset=utf-8`.
2. The `ETag` header is missing.

TODO(samwho): explain how to close this gap.

[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*
