---
title: Micro
excerpt: Micro
bottomNavigation: pagination
---

<Info>
  The Micro module is still in its experimental stages. We welcome your
  feedback to help us enhance its functionality.
</Info>

The `Micro` module in Effect serves as a lighter alternative to the standard `Effect` module, tailored for situations where it is beneficial to reduce the bundle size.

This module is self-contained, meaning it does not encompass more advanced features such as `Layer`, `Ref`, `Queue`, and `Deferred`. This characteristic makes Micro particularly suitable for libraries looking to integrate Effect features without significantly increasing the bundle size, especially those that intend to provide `Promise`-based APIs.

Micro also facilitates scenarios where a client might use Micro while a server employs the full suite of Effect features, ensuring both compatibility and consistency in logic across different parts of an application.

The inclusion of Micro adds a minimal footprint to your bundle, starting at **5kb gzipped**, and increases based on the features utilized.

<Warning>
  Utilizing major Effect modules beyond basic data modules like `Option`,
  `Either`, `Array`, etc., will incorporate the Effect runtime into your
  bundle, negating the benefits of Micro.
</Warning>

## Importing Micro

Micro is a part of the Effect library and can be imported just like any other module:

```ts
import * as Micro from "effect/Micro"
```

## The Micro Type

The `Micro` type utilizes three type parameters:

```ts
Micro<Success, Error, Requirements>
```

with the same meanings of the `Effect` type:

- **Success**. Represents the type of value that an effect can succeed with when executed.
  If this type parameter is `void`, it means the effect produces no useful information, while if it is `never`, it means the effect runs forever (or until failure).
- **Error**. Represents the expected errors that can occur when executing an effect.
  If this type parameter is `never`, it means the effect cannot fail, because there are no values of type `never`.
- **Requirements**. Represents the contextual data required by the effect to be executed.
  This data is stored in a collection named `Context`.
  If this type parameter is `never`, it means the effect has no requirements and the `Context` collection is empty.

## The Result Type

The `Result` type is a data type that represents the result of a `Micro` computation.

It uses the [Either](./data-types/either) data type to represent the success and failure cases:

```ts
type Result<A, E = never> = Either<A, Failure<E>>

type Failure<E> = Unexpected | Expected<E> | Aborted
```

## Creating Effects

| Effect              | Micro                 |                        |
| ------------------- | --------------------- | ---------------------- |
| `Effect.succeed`    | ✅ `Micro.succeed`    |                        |
| `Effect.fail`       | ✅ `Micro.fail`       |                        |
| `Effect.sync`       | ✅ `Micro.sync`       |                        |
| `Effect.try`        | ⚠️ `Micro.try`        | requires a `try` block |
| `Effect.promise`    | ✅ `Micro.promise`    |                        |
| `Effect.tryPromise` | ⚠️ `Micro.tryPromise` | requires a `try` block |
| `Effect.async`      | ✅ `Micro.async`      |                        |
| `Effect.suspend`    | ✅ `Micro.suspend`    |                        |

## Running Effects

| Effect                  | Micro                       |                                                |
| ----------------------- | --------------------------- | ---------------------------------------------- |
| `Effect.runSync`        | ✅ `Micro.runSync`          |                                                |
| `Effect.runSyncExit`    | ⚠️ `Micro.runSyncResult`    | returns a `Result` instead of an `Exit`        |
| `Effect.runPromise`     | ✅ `Micro.runSync`          |                                                |
| `Effect.runPromiseExit` | ⚠️ `Micro.runPromiseResult` | returns a `Result` instead of an `Exit`        |
| `Effect.runFork`        | ⚠️ `Micro.runFork`          | returns a `Handle` instead of a `RuntimeFiber` |

### runSyncResult

The `Effect.runSyncResult` function is used to execute an Effect synchronously, which means it runs immediately and returns the result as a [Result](#the-result-type).

```ts twoslash
import * as Micro from "effect/Micro"

const result1 = Micro.runSyncResult(Micro.succeed(1))
console.log(result1)
/*
Output:
{ _id: 'Either', _tag: 'Right', right: 1 }
*/

const result2 = Micro.runSyncResult(Micro.fail("my error"))
console.log(result2)
/*
Output:
{ _id: 'Either', _tag: 'Left', left: FailureExpected: my error }
*/
```

### runPromiseResult

The `Micro.runPromiseResult` function is used to execute an Effect and obtain the result as a `Promise` that resolves to a [Result](#the-result-type).

```ts twoslash
import * as Micro from "effect/Micro"

Micro.runPromiseResult(Micro.succeed(1)).then(console.log)
/*
Output:
{ _id: 'Either', _tag: 'Right', right: 1 }
*/

Micro.runPromiseResult(Micro.fail("my error")).then(console.log)
/*
Output:
{ _id: 'Either', _tag: 'Left', left: FailureExpected: my error }
*/
```

### runFork

The `Micro.runFork` function executes the effect and return a `Handle` that can be awaited, joined, or aborted.

You can listen for the result by adding an observer using the handle's `addObserver` method.

```ts twoslash
import * as Micro from "effect/Micro"

const handle = Micro.succeed(42).pipe(Micro.delay(1000), Micro.runFork)

handle.addObserver((result) => {
  console.log(result)
})
console.log("observing...")
/*
Output:
observing...
{ _id: 'Either', _tag: 'Right', right: 42 }
*/
```

## Using Generators

| Effect       | Micro          |                        |
| ------------ | -------------- | ---------------------- |
| `Effect.gen` | ⚠️ `Micro.gen` | doesn't support `this` |

## Building Pipelines

| Effect           | Micro               |                                                         |
| ---------------- | ------------------- | ------------------------------------------------------- |
| `.pipe()` method | ✅ `.pipe()` method |                                                         |
| `Effect.map`     | ✅ `Micro.map`      |                                                         |
| `Effect.as`      | ✅ `Micro.as`       |                                                         |
| `Effect.flatMap` | ✅ `Micro.flatMap`  |                                                         |
| `Effect.andThen` | ⚠️ `Micro.andThen`  | doesn't handle `Promise` or `() => Promise` as argument |
| `Effect.tap`     | ⚠️ `Micro.tap`      | doesn't handle `() => Promise` as argument              |
| `Effect.all`     | ⚠️ `Micro.all`      | no `batching` and `mode` options                        |

## Expected Errors

| Effect                  | Micro                      |     |
| ----------------------- | -------------------------- | --- |
| `Effect.either`         | ✅ `Micro.either`          |     |
| `Effect.catchTag`       | ✅ `Micro.catchTag`        |     |
| `Effect.catchAll`       | ✅ `Micro.catchExpected`   |     |
| `Effect.catchAllCause`  | ✅ `Micro.catchFailure`    |     |
| `Effect.catchAllDefect` | ✅ `Micro.catchUnexpected` |     |
| `Effect.catchIf`        | ❌                         |     |
| ❌                      | `Micro.catchFailureIf`     |     |

## Unexpected Errors

## Aborted Errors

## Requirements Management

## Control Flow
