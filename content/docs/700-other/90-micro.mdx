---
title: Micro
excerpt: Micro
bottomNavigation: pagination
---

<Info>
  The Micro module is currently in its experimental stages. We encourage your
  feedback to further improve its features.
</Info>

The `Micro` module in Effect is designed as a lighter alternative to the standard `Effect` module, tailored for situations where it is beneficial to reduce the bundle size.

This module is standalone and does not include more complex functionalities such as `Layer`, `Ref`, `Queue`, and `Deferred`. This feature set makes Micro especially suitable for libraries that wish to utilize Effect functionalities while keeping the bundle size to a minimum, particularly for those aiming to provide `Promise`-based APIs.

Micro also supports use cases where a client application uses Micro, and a server employs the full suite of Effect features, maintaining both compatibility and logical consistency across various application components.

Integrating Micro adds a minimal footprint to your bundle, starting at **5kb gzipped**, which may increase depending on the features you use.

<Warning>
  Utilizing major Effect modules beyond basic data modules like `Option`,
  `Either`, `Array`, will incorporate the Effect runtime into your bundle,
  negating the benefits of Micro.
</Warning>

## Importing Micro

Micro is a part of the Effect library and can be imported just like any other module:

```ts
import * as Micro from "effect/Micro"
```

## The Micro Type

The `Micro` type uses three type parameters:

```ts
Micro<Success, Error, Requirements>
```

which mirror those of the `Effect` type:

- **Success**. Represents the type of value that an effect can succeed with when executed.
  If this type parameter is `void`, it means the effect produces no useful information, while if it is `never`, it means the effect runs forever (or until failure).
- **Error**. Represents the expected errors that can occur when executing an effect.
  If this type parameter is `never`, it means the effect cannot fail, because there are no values of type `never`.
- **Requirements**. Represents the contextual data required by the effect to be executed.
  This data is stored in a collection named `Context`.
  If this type parameter is `never`, it means the effect has no requirements and the `Context` collection is empty.

## The Result Type

The `Result` type is a data structure that encapsulates the outcome of a `Micro` computation, utilizing the [Either](./data-types/either) data type to differentiate between success and failure scenarios:

```ts
type Result<A, E = never> = Either<A, Failure<E>>

type Failure<E> = Unexpected | Expected<E> | Aborted
```

## How to Use This Guide

Below, you'll find a series of comparisons between the functionalities of `Effect` and `Micro`. Each table lists a functionality of `Effect` alongside its counterpart in `Micro`. The icons used have the following meanings:

- ✅: The feature is available in `Micro`.
- ⚠️: The feature is available in `Micro`, but with some differences from `Effect`.
- ❌: The feature is not available in `Effect`.

## Creating Effects

| Effect                 | Micro                   |                                   |
| ---------------------- | ----------------------- | --------------------------------- |
| `Effect.succeed`       | ✅ `Micro.succeed`      |                                   |
| `Effect.succeedSome`   | ✅ `Micro.succeedSome`  |                                   |
| `Effect.succeedNone`   | ✅ `Micro.succeedNone`  |                                   |
| `Effect.fail`          | ✅ `Micro.fail`         |                                   |
| `Effect.failSync`      | ✅ `Micro.failSync`     |                                   |
| `Effect.sync`          | ✅ `Micro.sync`         |                                   |
| `Effect.try`           | ⚠️ `Micro.try`          | requires a `try` block            |
| `Effect.promise`       | ✅ `Micro.promise`      |                                   |
| `Effect.tryPromise`    | ⚠️ `Micro.tryPromise`   | requires a `try` block            |
| `Effect.async`         | ✅ `Micro.async`        |                                   |
| `Effect.suspend`       | ✅ `Micro.suspend`      |                                   |
| `Effect.sleep`         | ⚠️ `Micro.sleep`        | only handles milliseconds         |
| `Effect.failCause`     | ⚠️ `Micro.failWith`     | uses `Failure` instead of `Cause` |
| `Effect.failCauseSync` | ⚠️ `Micro.failWithSync` | uses `Failure` instead of `Cause` |
| ❌                     | `Micro.make`            |                                   |
| ❌                     | `Micro.fromOption`      |                                   |
| ❌                     | `Micro.fromEither`      |                                   |

## Running Effects

| Effect                  | Micro                       |                                                |
| ----------------------- | --------------------------- | ---------------------------------------------- |
| `Effect.runSync`        | ✅ `Micro.runSync`          |                                                |
| `Effect.runSyncExit`    | ⚠️ `Micro.runSyncResult`    | returns a `Result` instead of an `Exit`        |
| `Effect.runPromise`     | ✅ `Micro.runSync`          |                                                |
| `Effect.runPromiseExit` | ⚠️ `Micro.runPromiseResult` | returns a `Result` instead of an `Exit`        |
| `Effect.runFork`        | ⚠️ `Micro.runFork`          | returns a `Handle` instead of a `RuntimeFiber` |

### runSyncResult

The `Effect.runSyncResult` function is used to execute an Effect synchronously, which means it runs immediately and returns the result as a [Result](#the-result-type).

```ts twoslash
import * as Micro from "effect/Micro"

const result1 = Micro.runSyncResult(Micro.succeed(1))
console.log(result1)
/*
Output:
{ _id: 'Either', _tag: 'Right', right: 1 }
*/

const result2 = Micro.runSyncResult(Micro.fail("my error"))
console.log(result2)
/*
Output:
{ _id: 'Either', _tag: 'Left', left: FailureExpected: my error }
*/
```

### runPromiseResult

The `Micro.runPromiseResult` function is used to execute an Effect and obtain the result as a `Promise` that resolves to a [Result](#the-result-type).

```ts twoslash
import * as Micro from "effect/Micro"

Micro.runPromiseResult(Micro.succeed(1)).then(console.log)
/*
Output:
{ _id: 'Either', _tag: 'Right', right: 1 }
*/

Micro.runPromiseResult(Micro.fail("my error")).then(console.log)
/*
Output:
{ _id: 'Either', _tag: 'Left', left: FailureExpected: my error }
*/
```

### runFork

The `Micro.runFork` function executes the effect and return a `Handle` that can be awaited, joined, or aborted.

You can listen for the result by adding an observer using the handle's `addObserver` method.

```ts twoslash
import * as Micro from "effect/Micro"

const handle = Micro.succeed(42).pipe(Micro.delay(1000), Micro.runFork)

handle.addObserver((result) => {
  console.log(result)
})
console.log("observing...")
/*
Output:
observing...
{ _id: 'Either', _tag: 'Right', right: 42 }
*/
```

## Using Generators

| Effect       | Micro          |                        |
| ------------ | -------------- | ---------------------- |
| `Effect.gen` | ⚠️ `Micro.gen` | doesn't support `this` |

## Building Pipelines

| Effect             | Micro                |                                                         |
| ------------------ | -------------------- | ------------------------------------------------------- |
| `.pipe()` method   | ✅ `.pipe()` method  |                                                         |
| `Effect.map`       | ✅ `Micro.map`       |                                                         |
| `Effect.as`        | ✅ `Micro.as`        |                                                         |
| `Effect.flatMap`   | ✅ `Micro.flatMap`   |                                                         |
| `Effect.andThen`   | ⚠️ `Micro.andThen`   | doesn't handle `Promise` or `() => Promise` as argument |
| `Effect.tap`       | ⚠️ `Micro.tap`       | doesn't handle `() => Promise` as argument              |
| `Effect.all`       | ⚠️ `Micro.all`       | no `batching` and `mode` options                        |
| `Effect.forEach`   | ⚠️ `Micro.forEach`   | no `batching` option                                    |
| `Effect.filter`    | ⚠️ `Micro.filter`    | no `batching` option                                    |
| `Effect.filterMap` | ⚠️ `Micro.filterMap` | effectful                                               |

## Expected Errors

| Effect            | Micro                    |     |
| ----------------- | ------------------------ | --- |
| `Effect.either`   | ✅ `Micro.either`        |     |
| `Effect.catchTag` | ✅ `Micro.catchTag`      |     |
| `Effect.catchAll` | ✅ `Micro.catchExpected` |     |
| `Effect.catchIf`  | ✅ `Micro.catchIf`       |     |

## Unexpected Errors

| Effect                  | Micro                      |                    |
| ----------------------- | -------------------------- | ------------------ |
| `Effect.die`            | ✅ `Micro.die`             |                    |
| `Effect.orDie`          | ✅ `Micro.orDie`           |                    |
| `Effect.catchAllCause`  | ✅ `Micro.catchFailure`    |                    |
| `Effect.catchSomeCause` | ⚠️ `Micro.catchFailureIf`  | non `Option`-based |
| `Effect.catchAllDefect` | ✅ `Micro.catchUnexpected` |                    |

## Interruptions

| Effect                       | Micro                          |     |
| ---------------------------- | ------------------------------ | --- |
| `Effect.interrupt`           | ✅ `Micro.abort`               |     |
| `Effect.uninterruptible`     | ✅ `Micro.uninterruptible`     |     |
| `Effect.uninterruptibleMask` | ✅ `Micro.uninterruptibleMask` |     |
| `Effect.interruptible`       | ✅ `Micro.interruptible`       |     |

## Fallback

| Effect                 | Micro                    |     |
| ---------------------- | ------------------------ | --- |
| `Effect.orElseSucceed` | ✅ `Micro.orElseSucceed` |     |

## Matching

| Effect                    | Micro                        |     |
| ------------------------- | ---------------------------- | --- |
| `Effect.match`            | ✅ `Micro.match`             |     |
| `Effect.matchEffect`      | ✅ `Micro.matchMicro`        |     |
| `Effect.matchCause`       | ✅ `Micro.matchFailure`      |     |
| `Effect.matchCauseEffect` | ✅ `Micro.matchFailureMicro` |     |

## Retrying

| Effect         | Micro            |                     |
| -------------- | ---------------- | ------------------- |
| `Effect.retry` | ⚠️ `Micro.retry` | different `options` |

## Repetition

| Effect                          | Micro                   |                     |
| ------------------------------- | ----------------------- | ------------------- |
| `Effect.repeat`                 | ⚠️ `Micro.repeat`       | different `options` |
| `Effect.exit` + `Effect.repeat` | ⚠️ `Micro.repeatResult` |                     |

## Timing out

| Effect                 | Micro                 |     |
| ---------------------- | --------------------- | --- |
| `Effect.timeoutOption` | ✅ `Micro.timeout`    |     |
| ❌                     | `Micro.timeoutOrElse` |     |

## Sandboxing

| Effect           | Micro              |                                    |
| ---------------- | ------------------ | ---------------------------------- |
| `Effect.sandbox` | ⚠️ `Micro.sandbox` | `Failure<E>` instead of `Cause<E>` |

## Yieldable Errors

| Effect             | Micro                  |     |
| ------------------ | ---------------------- | --- |
| `Data.Error`       | ✅ `Micro.Error`       |     |
| `Data.TaggedError` | ✅ `Micro.TaggedError` |     |

## Error Channel Operations

| Effect                 | Micro                    |                                     |
| ---------------------- | ------------------------ | ----------------------------------- |
| `Effect.mapError`      | ✅ `Micro.mapError`      |                                     |
| `Effect.mapErrorCause` | ✅ `Micro.mapFailure`    |                                     |
| `Effect.filterOrFail`  | ✅ `Micro.filterOrFail`  |                                     |
| ❌                     | `Micro.filterOrFailWith` |                                     |
| `Effect.tapError`      | ✅ `Micro.tapExpected`   |                                     |
| `Effect.tapErrorCause` | ⚠️ `Micro.tapFailure`    | `Failure<E>` instead of `Cause<E>`  |
| ❌                     | `Micro.tapFailureIf`     |                                     |
| `Effect.tapDefect`     | ⚠️ `Micro.tapUnexpected` | `unknown` instead of `Cause<never>` |
| `Effect.flip`          | ✅ `Micro.flip`          |                                     |

## Requirements Management

| Effect                        | Micro                          |                        |
| ----------------------------- | ------------------------------ | ---------------------- |
| `Effect.provideService`       | ✅ `Micro.provideService`      |                        |
| `Effect.provideServiceEffect` | ✅ `Micro.provideServiceMicro` |                        |
| `Effect.provide`              | ⚠️ `Micro.provideContext`      | only handles `Context` |
| ❌                            | `Micro.provideScope`           |                        |
| `Effect.serviceOption`        | ✅ `Micro.serviceOption`       |                        |
| ❌                            | `Micro.service`                |                        |

## Scope

| Effect          | Micro             |     |
| --------------- | ----------------- | --- |
| `Effect.scoped` | ✅ `Micro.scoped` |     |

## Scoping, Resources and Finalization

| Effect                     | Micro                        |                                       |
| -------------------------- | ---------------------------- | ------------------------------------- |
| `Effect.addFinalizer`      | ⚠️ `Micro.addFinalizer`      | `Result` instead of `Exit` and no `R` |
| `Effect.acquireRelease`    | ⚠️ `Micro.acquireRelease`    | `Result` instead of `Exit`            |
| `Effect.acquireUseRelease` | ⚠️ `Micro.acquireUseRelease` | `Result` instead of `Exit`            |
| `Effect.onInterrupt`       | ✅ `Micro.onAbort`           |                                       |
| `Effect.onExit`            | ⚠️ `Micro.onResult`          | `Result` instead of `Exit`            |
| `Effect.onError`           | ⚠️ `Micro.onFailure`         | uses `Failure` instead of `Cause`     |
| ❌                         | `Micro.onResultIf`           |                                       |
| `Effect.ensuring`          | ✅ `Micro.ensuring`          |                                       |

## Concurrency

| Effect              | Micro                 |                                    |
| ------------------- | --------------------- | ---------------------------------- |
| `Effect.fork`       | ⚠️ `Micro.fork`       | `Handle` instead of `RuntimeFiber` |
| `Effect.forkDaemon` | ⚠️ `Micro.forkDaemon` | `Handle` instead of `RuntimeFiber` |
| `Effect.forkIn`     | ⚠️ `Micro.forkIn`     | `Handle` instead of `RuntimeFiber` |
| `Effect.forkScoped` | ⚠️ `Micro.forkScoped` | `Handle` instead of `RuntimeFiber` |

## Control Flow

| Effect                               | Micro             |     |
| ------------------------------------ | ----------------- | --- |
| `Effect.void`                        | ✅ `Micro.void`   |     |
| `Effect.asVoid`                      | ✅ `Micro.asVoid` |     |
| `Effect.when` \| `Effect.whenEffect` | ✅ `Micro.when`   |     |
| `Effect.zip`                         | ✅ `Micro.zip`    |     |

## Do Notation

| Effect          | Micro             |     |
| --------------- | ----------------- | --- |
| `Effect.Do`     | ✅ `Micro.Do`     |     |
| `Effect.let`    | ✅ `Micro.let`    |     |
| `Effect.bindTo` | ✅ `Micro.bindTo` |     |
| `Effect.bind`   | ✅ `Micro.bind`   |     |
