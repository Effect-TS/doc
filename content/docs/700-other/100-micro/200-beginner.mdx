---
title: Getting Started with Micro
excerpt: "Getting Started with Micro: A Primer for New Users"
bottomNavigation: pagination
---

## Importing Micro

Before you start, make sure you have completed the following setup:

- Install the `effect` library in your project. If it is not already installed, you can add it using npm with the following command:
  ```bash
  npm install effect
  ```

Micro is a component of the Effect library and can be imported similarly to any other module in your TypeScript project:

```ts
import * as Micro from "effect/Micro"
```

This import statement allows you to access all functionalities of Micro, enabling you to use its features in your application.

## The Micro Type

The `Micro` type uses three type parameters:

```ts
Micro<Success, Error, Requirements>
```

which mirror those of the `Effect` type:

- **Success**. Represents the type of value that an effect can succeed with when executed.
  If this type parameter is `void`, it means the effect produces no useful information, while if it is `never`, it means the effect runs forever (or until failure).
- **Error**. Represents the expected errors that can occur when executing an effect.
  If this type parameter is `never`, it means the effect cannot fail, because there are no values of type `never`.
- **Requirements**. Represents the contextual data required by the effect to be executed.
  This data is stored in a collection named `Context`.
  If this type parameter is `never`, it means the effect has no requirements and the `Context` collection is empty.

## Tutorial: Wrapping a Promise-based API with Micro

In this tutorial, we'll demonstrate how to wrap a Promise-based API using the `Micro` library from Effect. We'll use a simple example where we interact with a hypothetical weather forecasting API. The goal is to encapsulate the asynchronous API call within Micro's structured error handling and execution flow.

### Step 1: Create a Promise-based API Function

First, let's define a simple Promise-based function that simulates fetching weather data from an external service.

```ts twoslash
function fetchWeather(city: string): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (city === "London") {
        resolve("Sunny")
      } else {
        reject(new Error("Weather data not found for this location"))
      }
    }, 1000)
  })
}
```

### Step 2: Wrap the Promise with Micro

Next, we'll wrap our `fetchWeather` function using Micro to handle both successful and failed Promise outcomes.

```ts twoslash
import * as Micro from "effect/Micro"

function fetchWeather(city: string): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (city === "London") {
        resolve("Sunny")
      } else {
        reject(new Error("Weather data not found for this location"))
      }
    }, 1000)
  })
}

function getWeather(city: string) {
  return Micro.promise(() => fetchWeather(city))
}
```

Here, `Micro.promise` is used to convert the Promise returned by `fetchWeather` into a Micro effect.

### Step 3: Running the Micro Effect

After wrapping our function, we need to execute the Micro effect and handle the results.

```ts twoslash
import * as Micro from "effect/Micro"

function fetchWeather(city: string): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (city === "London") {
        resolve("Sunny")
      } else {
        reject(new Error("Weather data not found for this location"))
      }
    }, 1000)
  })
}

function getWeather(city: string) {
  return Micro.promise(() => fetchWeather(city))
}
// ---cut---
const weatherEffect = getWeather("London")

Micro.runPromise(weatherEffect)
  .then((result) => console.log(`The weather in London is: ${result}`))
  .catch((error) =>
    console.error(`Failed to fetch weather data: ${error.message}`)
  )
/*
Output:
The weather in London is: Sunny
*/
```

In this snippet, `Micro.runPromise` is used to execute the `weatherEffect`.
It converts the Micro effect back into a Promise, making it easier to integrate with other Promise-based code or simply to manage asynchronous operations in a familiar way.

### Step 4: Adding Error Handling

To further enhance the function, you might want to handle specific errors differently.
Micro provides methods like `Micro.tryPromise` to handle anticipated errors gracefully.

```ts twoslash
import * as Micro from "effect/Micro"

function fetchWeather(city: string): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (city === "London") {
        resolve("Sunny")
      } else {
        reject(new Error("Weather data not found for this location"))
      }
    }, 1000)
  })
}
// ---cut---
class WeatherError {
  readonly _tag = "WeatherError"
  constructor(readonly message: string) {}
}

function getWeather(city: string) {
  return Micro.tryPromise({
    try: () => fetchWeather(city),
    // remap the error
    catch: (error) => new WeatherError(String(error))
  })
}

const weatherEffect = getWeather("Paris")

Micro.runPromise(weatherEffect)
  .then((result) => console.log(`The weather in London is: ${result}`))
  .catch((error) => console.error(`Failed to fetch weather data: ${error}`))
/*
Output:
Failed to fetch weather data: FailureExpected: {"_tag":"WeatherError","message":"Error: Weather data not found for this location"}
*/
```
