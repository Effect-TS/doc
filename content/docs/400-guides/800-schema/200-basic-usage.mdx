---
title: Basic Usage
excerpt: Basic Usage
bottomNavigation: pagination
---

## Cheatsheet

| Typescript Type                                           | Description / Notes                      | Schema / Combinator / Example                                              |
| --------------------------------------------------------- | ---------------------------------------- | -------------------------------------------------------------------------- |
| `null`                                                    |                                          | `S.Null`                                                                   |
| `undefined`                                               |                                          | `S.Undefined`                                                              |
| `string`                                                  |                                          | `S.String`                                                                 |
| `number`                                                  |                                          | `S.Number`                                                                 |
| `boolean`                                                 |                                          | `S.Boolean`                                                                |
| `symbol`                                                  |                                          | `S.SymbolFromSelf` / `S.Symbol`                                            |
| `BigInt`                                                  |                                          | `S.BigIntFromSelf` / `S.BigInt`                                            |
| `unknown`                                                 |                                          | `S.Unknown`                                                                |
| `any`                                                     |                                          | `S.Any`                                                                    |
| `never`                                                   |                                          | `S.Never`                                                                  |
| `object`                                                  |                                          | `S.Object`                                                                 |
| `unique symbol`                                           |                                          | `S.UniqueSymbolFromSelf`                                                   |
| `"a"`, `1`, `true`                                        | type literals                            | `S.Literal("a")`, `S.Literal(1)`, `S.Literal(true)`                        |
| `a${string}`                                              | template literals                        | `S.TemplateLiteral("a", S.String)`                                         |
| `{ readonly a: string, readonly b?: number\| undefined }` | structs                                  | `S.Struct({ a: S.String, b: S.optional(S.Number) })`                       |
| `Record<A, B>`                                            | records                                  | `S.Record({ key: A, value: B })`                                           |
| `readonly [string, number]`                               | tuples                                   | `S.Tuple(S.String, S.Number)`                                              |
| `ReadonlyArray<string>`                                   | arrays                                   | `S.Array(S.String)`                                                        |
| `A \| B`                                                  | unions                                   | `S.Union(A, B)`                                                            |
| `A & B`                                                   | intersections of non-overlapping structs | `S.extend(A, B)`                                                           |
| `Record<A, B> & Record<C, D>`                             | intersections of non-overlapping records | `S.extend(S.Record({ key: A, value: B }), S.Record({ key: C, value: D }))` |
| `type A = { a: A \| null }`                               | recursive types                          | `S.Struct({ a: S.Union(S.Null, S.suspend(() => self)) })`                  |
| `keyof A`                                                 |                                          | `S.keyof(A)`                                                               |
| `Partial<A>`                                              |                                          | `S.partial(A)`                                                             |
| `Required<A>`                                             |                                          | `S.required(A)`                                                            |

Here are the primitive schemas provided by the `@effect/schema/Schema` module:

## Primitives

These primitive schemas are building blocks for creating more complex schemas to describe your data structures.

```ts
import { Schema } from "@effect/schema"

Schema.String // Schema<string>
Schema.Number // Schema<number>
Schema.Boolean // Schema<boolean>
Schema.BigIntFromSelf // Schema<BigInt>
Schema.SymbolFromSelf // Schema<symbol>
Schema.Object // Schema<object>
Schema.Undefined // Schema<undefined>
Schema.Void // Schema<void>
Schema.Any // Schema<any>
Schema.Unknown // Schema<unknown>
Schema.Never // Schema<never>
```

## Literals

Literals represent specific values that are directly specified.

```ts
import { Schema } from "@effect/schema"

Schema.Null // same as S.Literal(null)
Schema.Literal("a")
Schema.Literal("a", "b", "c") // union of literals
Schema.Literal(1)
Schema.Literal(2n) // BigInt literal
Schema.Literal(true)
```

**Exposed Values**

You can access the literals of a literal schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Literal("a", "b")

// Accesses the literals
const literals = schema.literals
```

**The pickLiteral Utility**

We can also use `Schema.pickLiteral` with a literal schema to narrow down the possible values:

```ts twoslash
import { Schema } from "@effect/schema"

Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b")) // same as S.Literal("a", "b")
```

Sometimes, we need to reuse a schema literal in other parts of our code. Let's see an example:

```ts twoslash
import { Schema } from "@effect/schema"

const FruitId = Schema.Number
// the source of truth regarding the Fruit category
const FruitCategory = Schema.Literal("sweet", "citrus", "tropical")

const Fruit = Schema.Struct({
  id: FruitId,
  category: FruitCategory
})

// Here, we want to reuse our FruitCategory definition to create a subtype of Fruit
const SweetAndCitrusFruit = Schema.Struct({
  fruitId: FruitId,
  category: FruitCategory.pipe(Schema.pickLiteral("sweet", "citrus"))
  /*
    By using pickLiteral from the FruitCategory, we ensure that the values selected
    are those defined in the category definition above.
    If we remove "sweet" from the FruitCategory definition, TypeScript will notify us.
  */
})
```

In this example, `FruitCategory` serves as the source of truth for the categories of fruits. We reuse it to create a subtype of `Fruit` called `SweetAndCitrusFruit`, ensuring that only the categories defined in `FruitCategory` are allowed.

## Template literals

In TypeScript, template literals allow you to embed expressions within string literals.
The `Schema.TemplateLiteral` constructor allows you to create a schema for these template literal types.

Here's how you can use it:

```ts twoslash
import { Schema } from "@effect/schema"

// This creates a TemplateLiteral of type `a${string}`
Schema.TemplateLiteral("a", Schema.String)

// This creates a TemplateLiteral of type `https://${string}.com` or `https://${string}.net`
Schema.TemplateLiteral(
  "https://",
  Schema.String,
  ".",
  Schema.Literal("com", "net")
)
```

Let's look at a more complex example. Suppose you have two sets of locale IDs for emails and footers:

```ts twoslash
import { Schema } from "@effect/schema"

// example from https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
const EmailLocaleIDs = Schema.Literal("welcome_email", "email_heading")
const FooterLocaleIDs = Schema.Literal("footer_title", "footer_sendoff")
```

You can use the `Schema.TemplateLiteral` constructor to create a schema that combines these IDs:

```ts twoslash
import { Schema } from "@effect/schema"

const EmailLocaleIDs = Schema.Literal("welcome_email", "email_heading")
const FooterLocaleIDs = Schema.Literal("footer_title", "footer_sendoff")

// ---cut---
// This creates a TemplateLiteral of type "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
Schema.TemplateLiteral(Schema.Union(EmailLocaleIDs, FooterLocaleIDs), "_id")
```

The `Schema.TemplateLiteral` constructor supports the following types of spans:

- `Schema.String`
- `Schema.Number`
- Literals: `string | number | boolean | null | bigint`. These can be either wrapped by `Schema.Literal` or used directly
- Unions of the above types

## TemplateLiteralParser

The `Schema.TemplateLiteral` constructor, while useful as a simple validator, only verifies that an input conforms to a specific string pattern by converting template literal definitions into regular expressions. Similarly, `Schema.pattern` employs regular expressions directly for the same purpose. Post-validation, both methods require additional manual parsing to convert the validated string into a usable data format.

To address these limitations and eliminate the need for manual post-validation parsing, the new `TemplateLiteralParser` API has been developed. It not only validates the input format but also automatically parses it into a more structured and type-safe output, specifically into a **tuple** format.

This new approach enhances developer productivity by reducing boilerplate code and simplifying the process of working with complex string inputs.

**Example**

```ts twoslash
import { Schema } from "@effect/schema"

// const schema: Schema.Schema<readonly [number, "a", string], `${string}a${string}`, never>
const schema = Schema.TemplateLiteralParser(
  Schema.NumberFromString,
  "a",
  Schema.NonEmptyString
)

console.log(Schema.decodeEither(schema)("100afoo"))
// { _id: 'Either', _tag: 'Right', right: [ 100, 'a', 'foo' ] }

console.log(Schema.encode(schema)([100, "a", "foo"]))
// { _id: 'Either', _tag: 'Right', right: '100afoo' }
```

## Unique Symbols

```ts twoslash
import { Schema } from "@effect/schema"

const mySymbol = Symbol.for("mysymbol")

// const mySymbolSchema: S.Schema<typeof mySymbol>
const mySymbolSchema = Schema.UniqueSymbolFromSelf(mySymbol)
```

## Filters

Using the `Schema.filter` function, developers can define custom validation logic that goes beyond basic type checks, allowing for in-depth control over the data conformity process. This function applies a predicate to data, and if the data fails the predicate's condition, a custom error message can be returned.

<Info>
  For effectful filters, see
  [filterEffect](transformations#effectful-filters).
</Info>

**Example: Simple Validation**

```ts twoslash
import { Schema } from "@effect/schema"

const LongString = Schema.String.pipe(
  Schema.filter(
    (s) => s.length >= 10 || "a string at least 10 characters long"
  )
)

// string
type LongString = typeof LongString.Type

console.log(Schema.decodeUnknownSync(LongString)("a"))
/*
throws:
ParseError: { string | filter }
└─ Predicate refinement failure
   └─ a string at least 10 characters long
*/
```

<Info>
  Please note that the use of filters do not alter the `Type` of the schema.
  They only serve to add additional constraints to the parsing process. If you
  intend to modify the `Type`, consider using [Branded types](#branded-types).
</Info>

### Predicate Function Structure

The predicate for a filter is defined as follows:

```ts
type Predicate = (
  a: A,
  options: ParseOptions,
  self: AST.Refinement
) => FilterReturnType
```

where

```ts
interface FilterIssue {
  readonly path: ReadonlyArray<PropertyKey>
  readonly issue: string | ParseResult.ParseIssue
}

type FilterOutput =
  | undefined
  | boolean
  | string
  | ParseResult.ParseIssue
  | FilterIssue

type FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>
```

Filter predicates can return several types of values, each with specific implications:

- `true`: The data satisfies the filter's condition.
- `false` or `undefined`: The filter is not satisfied, and no specific error message is provided.
- `string`: The filter fails, and the provided string is used as the default error message.
- `ParseResult.ParseIssue`: The filter fails with a detailed error structure.
- `FilterIssue`: Allows specifying detailed error paths and messages, enhancing error specificity.

An array can be returned if multiple issues need to be reported, allowing for complex validations that may have multiple points of failure.

### Annotations

It's beneficial to embed as much metadata as possible within the schema. This metadata can include identifiers, JSON schema specifications, and descriptive text to facilitate later analysis and understanding of the schema's purpose and constraints.

**Example**

```ts twoslash
import { Schema } from "@effect/schema"

const LongString = Schema.String.pipe(
  Schema.filter(
    (s) =>
      s.length >= 10 ? undefined : "a string at least 10 characters long",
    {
      identifier: "LongString",
      jsonSchema: { minLength: 10 },
      description:
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua"
    }
  )
)

console.log(Schema.decodeUnknownSync(LongString)("a"))
/*
throws:
ParseError: { string | filter }
└─ Predicate refinement failure
   └─ a string at least 10 characters long
*/
```

### Specifying Error Paths

It's possible to specify an error path along with the message, which enhances error specificity and is particularly beneficial for integration with tools like [react-hook-form](https://react-hook-form.com/).

**Example**

```ts twoslash
import { ArrayFormatter, Schema } from "@effect/schema"
import { Either } from "effect"

const Password = Schema.Trim.pipe(Schema.minLength(1))

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password
}).pipe(
  Schema.filter((input) => {
    if (input.password !== input.confirm_password) {
      return {
        path: ["confirm_password"],
        message: "Passwords do not match"
      }
    }
  })
)

console.log(
  JSON.stringify(
    Schema.decodeUnknownEither(MyForm)({
      password: "abc",
      confirm_password: "d"
    }).pipe(Either.mapLeft((error) => ArrayFormatter.formatErrorSync(error))),
    null,
    2
  )
)
/*
  "_id": "Either",
  "_tag": "Left",
  "left": [
    {
      "_tag": "Type",
      "path": [
        "confirm_password"
      ],
      "message": "Passwords do not match"
    }
  ]
}
*/
```

This allows the error to be directly associated with the `confirm_password` field, improving clarity for the end-user.

<Info>
  The use of `ArrayFormatter` translates the error details into a more
  comprehensible format. For further details, see
  [ArrayFormatter](error-formatters#arrayformatter).
</Info>

### Multiple Error Reporting

The `Schema.filter` API also supports reporting multiple issues at once, which is useful in forms where several validation checks might fail simultaneously.

**Example**

```ts twoslash
import { ArrayFormatter, Schema } from "@effect/schema"
import { Either } from "effect"

const Password = Schema.Trim.pipe(Schema.minLength(1))
const OptionalString = Schema.optional(Schema.String)

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password,
  name: OptionalString,
  surname: OptionalString
}).pipe(
  Schema.filter((input) => {
    const issues: Array<Schema.FilterIssue> = []
    // passwords must match
    if (input.password !== input.confirm_password) {
      issues.push({
        path: ["confirm_password"],
        message: "Passwords do not match"
      })
    }
    // either name or surname must be present
    if (!input.name && !input.surname) {
      issues.push({
        path: ["surname"],
        message: "Surname must be present if name is not present"
      })
    }
    return issues
  })
)

console.log(
  JSON.stringify(
    Schema.decodeUnknownEither(MyForm)({
      password: "abc",
      confirm_password: "d"
    }).pipe(Either.mapLeft((error) => ArrayFormatter.formatErrorSync(error))),
    null,
    2
  )
)
/*
{
  "_id": "Either",
  "_tag": "Left",
  "left": [
    {
      "_tag": "Type",
      "path": [
        "confirm_password"
      ],
      "message": "Passwords do not match"
    },
    {
      "_tag": "Type",
      "path": [
        "surname"
      ],
      "message": "Surname must be present if name is not present"
    }
  ]
}
*/
```

<Info>
  The use of `ArrayFormatter` translates the error details into a more
  comprehensible format. For further details, see
  [ArrayFormatter](error-formatters#arrayformatter).
</Info>

### Exposed Values

You can access the base schema for which the filter has been defined:

```ts twoslash
import { Schema } from "@effect/schema"

const LongString = Schema.String.pipe(Schema.filter((s) => s.length >= 10))

// const From: typeof Schema.String
const From = LongString.from
```

In this example, you're able to access the original schema (`Schema.String`) for which the filter (`LongString`) has been defined. The `from` property provides access to this base schema.

### String Filters

```ts
import { Schema } from "@effect/schema"

// Specifies maximum length of a string
Schema.String.pipe(Schema.maxLength(5))

// Specifies minimum length of a string
Schema.String.pipe(Schema.minLength(5))

// Equivalent to ensuring the string has a minimum length of 1
Schema.NonEmptyString

// Specifies exact length of a string
Schema.String.pipe(Schema.length(5))

// Specifies a range for the length of a string
Schema.String.pipe(Schema.length({ min: 2, max: 4 }))

// Matches a string against a regular expression pattern
Schema.String.pipe(Schema.pattern(regex))

// Ensures a string starts with a specific substring
Schema.String.pipe(Schema.startsWith(string))

// Ensures a string ends with a specific substring
Schema.String.pipe(Schema.endsWith(string))

// Checks if a string includes a specific substring
Schema.String.pipe(Schema.includes(searchString))

// Validates that a string has no leading or trailing whitespaces
Schema.String.pipe(Schema.trimmed())

// Validates that a string is entirely in lowercase
Schema.String.pipe(Schema.lowercased())
```

<Info>
  The `trimmed` combinator does not make any transformations, it only
  validates. If what you were looking for was a combinator to trim strings,
  then check out the `trim` combinator ot the `Trim` schema.
</Info>

### Number Filters

```ts twoslash
import { Schema } from "@effect/schema"

// Specifies a number greater than 5
Schema.Number.pipe(Schema.greaterThan(5))

// Specifies a number greater than or equal to 5
Schema.Number.pipe(Schema.greaterThanOrEqualTo(5))

// Specifies a number less than 5
Schema.Number.pipe(Schema.lessThan(5))

// Specifies a number less than or equal to 5
Schema.Number.pipe(Schema.lessThanOrEqualTo(5))

// Specifies a number between -2 and 2, inclusive
Schema.Number.pipe(Schema.between(-2, 2))

// Specifies that the value must be an integer
Schema.Number.pipe(Schema.int())

// Ensures the value is not NaN
Schema.Number.pipe(Schema.nonNaN())

// Ensures the value is finite and not Infinity or -Infinity
Schema.Number.pipe(Schema.finite())

// Specifies a positive number (> 0)
Schema.Number.pipe(Schema.positive())

// Specifies a non-negative number (>= 0)
Schema.Number.pipe(Schema.nonNegative())

// Specifies a negative number (< 0)
Schema.Number.pipe(Schema.negative())

// Specifies a non-positive number (<= 0)
Schema.Number.pipe(Schema.nonPositive())

// Specifies a number that is evenly divisible by 5
Schema.Number.pipe(Schema.multipleOf(5))
```

### BigInt Filters

```ts
import { Schema } from "@effect/schema"

// Specifies a BigInt greater than 5
Schema.BigInt.pipe(Schema.greaterThanBigInt(5n))

// Specifies a BigInt greater than or equal to 5
Schema.BigInt.pipe(Schema.greaterThanOrEqualToBigInt(5n))

// Specifies a BigInt less than 5
Schema.BigInt.pipe(Schema.lessThanBigInt(5n))

// Specifies a BigInt less than or equal to 5
Schema.BigInt.pipe(Schema.lessThanOrEqualToBigInt(5n))

// Specifies a BigInt between -2 and 2, inclusive
Schema.BigInt.pipe(Schema.betweenBigInt(-2n, 2n))

// Specifies a positive BigInt (> 0n)
Schema.BigInt.pipe(Schema.positiveBigInt())

// Specifies a non-negative BigInt (>= 0n)
Schema.BigInt.pipe(Schema.nonNegativeBigInt())

// Specifies a negative BigInt (< 0n)
Schema.BigInt.pipe(Schema.negativeBigInt())

// Specifies a non-positive BigInt (<= 0n)
Schema.BigInt.pipe(Schema.nonPositiveBigInt())
```

### BigDecimal Filters

```ts twoslash
import { Schema } from "@effect/schema"
import { BigDecimal } from "effect"

// Specifies a BigDecimal greater than 5
Schema.BigDecimal.pipe(Schema.greaterThanBigDecimal(BigDecimal.fromNumber(5)))

// Specifies a BigDecimal greater than or equal to 5
Schema.BigDecimal.pipe(
  Schema.greaterThanOrEqualToBigDecimal(BigDecimal.fromNumber(5))
)
// Specifies a BigDecimal less than 5
Schema.BigDecimal.pipe(Schema.lessThanBigDecimal(BigDecimal.fromNumber(5)))

// Specifies a BigDecimal less than or equal to 5
Schema.BigDecimal.pipe(
  Schema.lessThanOrEqualToBigDecimal(BigDecimal.fromNumber(5))
)

// Specifies a BigDecimal between -2 and 2, inclusive
Schema.BigDecimal.pipe(
  Schema.betweenBigDecimal(
    BigDecimal.fromNumber(-2),
    BigDecimal.fromNumber(2)
  )
)

// Specifies a positive BigDecimal (> 0)
Schema.BigDecimal.pipe(Schema.positiveBigDecimal())

// Specifies a non-negative BigDecimal (>= 0)
Schema.BigDecimal.pipe(Schema.nonNegativeBigDecimal())

// Specifies a negative BigDecimal (< 0)
Schema.BigDecimal.pipe(Schema.negativeBigDecimal())

// Specifies a non-positive BigDecimal (<= 0)
Schema.BigDecimal.pipe(Schema.nonPositiveBigDecimal())
```

### Duration Filters

```ts twoslash
import { Schema } from "@effect/schema"

// Specifies a duration greater than 5 seconds
Schema.Duration.pipe(Schema.greaterThanDuration("5 seconds"))

// Specifies a duration greater than or equal to 5 seconds
Schema.Duration.pipe(Schema.greaterThanOrEqualToDuration("5 seconds"))

// Specifies a duration less than 5 seconds
Schema.Duration.pipe(Schema.lessThanDuration("5 seconds"))

// Specifies a duration less than or equal to 5 seconds
Schema.Duration.pipe(Schema.lessThanOrEqualToDuration("5 seconds"))

// Specifies a duration between 5 seconds and 10 seconds, inclusive
Schema.Duration.pipe(Schema.betweenDuration("5 seconds", "10 seconds"))
```

### Array Filters

```ts twoslash
import { Schema } from "@effect/schema"

// Specifies the maximum number of items in the array
Schema.Array(Schema.Number).pipe(Schema.maxItems(2))

// Specifies the minimum number of items in the array
Schema.Array(Schema.Number).pipe(Schema.minItems(2))

// Specifies the exact number of items in the array
Schema.Array(Schema.Number).pipe(Schema.itemsCount(2))
```

## Branded types

TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.
This can cause issues when types that are semantically different are treated as if they were the same.

```ts twoslash
type UserId = string
type Username = string

declare const getUser: (id: UserId) => object

const myUsername: Username = "gcanti"

getUser(myUsername) // This erroneously works
```

In the above example, `UserId` and `Username` are both aliases for the same type, `string`. This means that the `getUser` function can mistakenly accept a `Username` as a valid `UserId`, causing bugs and errors.

To avoid these kinds of issues, the Effect ecosystem provides a way to create custom types with a unique identifier attached to them. These are known as **branded types**.

```ts twoslash
// @errors: 2345
import { Brand } from "effect"

type UserId = string & Brand.Brand<"UserId">
type Username = string

declare const getUser: (id: UserId) => object

const myUsername: Username = "gcanti"

getUser(myUsername)
```

By defining `UserId` as a branded type, the `getUser` function can accept only values of type `UserId`, and not plain strings or other types that are compatible with strings. This helps to prevent bugs caused by accidentally passing the wrong type of value to the function.

There are two ways to define a schema for a branded type, depending on whether you:

- want to define the schema from scratch
- have already defined a [branded type](../style/branded-types) via `effect/Brand` and want to reuse it to define a schema

### Defining a brand schema from scratch

To define a schema for a branded type from scratch, you can use the `Schema.brand` function.

```ts twoslash
import { Schema } from "@effect/schema"

const UserId = Schema.String.pipe(Schema.brand("UserId"))

// string & Brand<"UserId">
type UserId = Schema.Schema.Type<typeof UserId>
```

Note that you can use `unique symbol`s as brands to ensure uniqueness across modules / packages:

```ts twoslash
import { Schema } from "@effect/schema"

const UserIdBrand = Symbol.for("UserId")

const UserId = Schema.String.pipe(Schema.brand(UserIdBrand))

// string & Brand<typeof UserIdBrand>
type UserId = Schema.Schema.Type<typeof UserId>
```

### Reusing an existing branded constructor

If you have already defined a [branded type](../style/branded-types) using the `effect/Brand` module, you can reuse it to define a schema using the `fromBrand` combinator exported by the `@effect/schema/Schema` module.

```ts twoslash
import { Schema } from "@effect/schema"
import { Brand } from "effect"

// the existing branded type
type UserId = string & Brand.Brand<"UserId">

const UserId = Brand.nominal<UserId>()

// Define a schema for the branded type
const UserIdSchema = Schema.String.pipe(Schema.fromBrand(UserId))
```

### Utilizing Default Constructors

The `Schema.brand` function includes a default constructor to facilitate the creation of branded values.

```ts twoslash
import { Schema } from "@effect/schema"

const UserId = Schema.String.pipe(Schema.brand("UserId"))

const userId = UserId.make("123") // Creates a branded UserId
```

## Native enums

```ts twoslash
import { Schema } from "@effect/schema"

enum Fruits {
  Apple,
  Banana
}

// Schema.Enums<typeof Fruits>
const schema = Schema.Enums(Fruits)
```

### Accessing Enum Members

Enums are exposed under an `enums` property of the schema:

```ts twoslash
import { Schema } from "@effect/schema"

enum Fruits {
  Apple,
  Banana
}

const schema = Schema.Enums(Fruits)

// ---cut---
// Access the enum members
schema.enums // Returns all enum members
schema.enums.Apple // Access the Apple member
schema.enums.Banana // Access the Banana member
```

## Unions

The Schema module includes a built-in `Union` constructor for composing "OR" types.

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Union(Schema.String, Schema.Number)
```

### Union of Literals

While the following is perfectly acceptable:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Union(
  Schema.Literal("a"),
  Schema.Literal("b"),
  Schema.Literal("c")
)
```

It is possible to use `Literal` and pass multiple literals, which is less cumbersome:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Literal("a", "b", "c")
```

### Nullables

```ts twoslash
import { Schema } from "@effect/schema"

// Represents a schema for a string or null value
Schema.NullOr(Schema.String)

// Represents a schema for a string, null, or undefined value
Schema.NullishOr(Schema.String)

// Represents a schema for a string or undefined value
Schema.UndefinedOr(Schema.String)
```

### Discriminated unions

TypeScript reference: https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions

Discriminated unions in TypeScript are a way of modeling complex data structures that may take on different forms based on a specific set of conditions or properties. They allow you to define a type that represents multiple related shapes, where each shape is uniquely identified by a shared discriminant property.

In a discriminated union, each variant of the union has a common property, called the discriminant. The discriminant is a literal type, which means it can only have a finite set of possible values. Based on the value of the discriminant property, TypeScript can infer which variant of the union is currently in use.

Here is an example of a discriminated union in TypeScript:

```ts twoslash
type Circle = {
  readonly kind: "circle"
  readonly radius: number
}

type Square = {
  readonly kind: "square"
  readonly sideLength: number
}

type Shape = Circle | Square
```

This code defines a discriminated union using the Schema module:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({
  kind: Schema.Literal("circle"),
  radius: Schema.Number
})

const Square = Schema.Struct({
  kind: Schema.Literal("square"),
  sideLength: Schema.Number
})

const Shape = Schema.Union(Circle, Square)
```

The `Literal` constructor is used to define the discriminant property with a specific string literal value.

Two structs are defined for `Circle` and `Square`, each with their own properties. These structs represent the variants of the union.

Finally, the `Union` constructor is used to create a schema for the discriminated union `Shape`, which is a union of `Circle` and `Square`.

### How to transform a simple union into a discriminated union

If you're working on a TypeScript project and you've defined a simple union to represent a particular input, you may find yourself in a situation where you're not entirely happy with how it's set up.
For example, let's say you've defined a `Shape` union as a combination of `Circle` and `Square` without any special property:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({
  radius: Schema.Number
})

const Square = Schema.Struct({
  sideLength: Schema.Number
})

const Shape = Schema.Union(Circle, Square)
```

To make your code more manageable, you may want to transform the simple union into a discriminated union. This way, TypeScript will be able to automatically determine which member of the union you're working with based on the value of a specific property.

To achieve this, you can add a special property to each member of the union, which will allow TypeScript to know which type it's dealing with at runtime.
Here's how you can [transform](transformations#transform) the `Shape` schema into another schema that represents a discriminated union:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({
  radius: Schema.Number
})

const Square = Schema.Struct({
  sideLength: Schema.Number
})

const DiscriminatedShape = Schema.Union(
  Schema.transform(
    Circle,
    Schema.Struct({ ...Circle.fields, kind: Schema.Literal("circle") }), // Add a "kind" property with the literal value "circle" to Circle
    {
      strict: true,
      decode: (circle) => ({ ...circle, kind: "circle" as const }), // Add the discriminant property to Circle
      encode: ({ kind: _kind, ...rest }) => rest // Remove the discriminant property
    }
  ),

  Schema.transform(
    Square,
    Schema.Struct({ ...Square.fields, kind: Schema.Literal("square") }), // Add a "kind" property with the literal value "square" to Square
    {
      strict: true,
      decode: (square) => ({ ...square, kind: "square" as const }), // Add the discriminant property to Square
      encode: ({ kind: _kind, ...rest }) => rest // Remove the discriminant property
    }
  )
)

console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ radius: 10 }))
// Output: { kind: 'circle', radius: 10 }

console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ sideLength: 10 }))
// Output: { kind: 'square', sideLength: 10 }
```

The previous solution works perfectly and shows how we can add properties to our schema at will, making it easier to consume the result within our domain model.
However, it requires a lot of boilerplate. Fortunately, there is an API called `Schema.attachPropertySignature` designed specifically for this use case, which allows us to achieve the same result with much less effort:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({ radius: Schema.Number })
const Square = Schema.Struct({ sideLength: Schema.Number })
const DiscriminatedShape = Schema.Union(
  Circle.pipe(Schema.attachPropertySignature("kind", "circle")),
  Square.pipe(Schema.attachPropertySignature("kind", "square"))
)

// decoding
console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ radius: 10 }))
// Output: { kind: 'circle', radius: 10 }

// encoding
console.log(
  Schema.encodeSync(DiscriminatedShape)({
    kind: "circle",
    radius: 10
  })
)
// Output: { radius: 10 }
```

<Warning>
  Please note that with `Schema.attachPropertySignature`, you can only add a
  property, it cannot override an existing one.
</Warning>

### Exposed Values

You can access the individual members of a union schema represented as a tuple:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Union(Schema.String, Schema.Number)

// Accesses the members of the union
const members = schema.members
```

## Tuples

### Required Elements

To define a tuple with required elements, you specify the list of elements:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(Schema.String, Schema.Number)
```

### Append a Required Element

```ts twoslash
import { Schema } from "@effect/schema"

const tuple1 = Schema.Tuple(Schema.String, Schema.Number)

const tuple2 = Schema.Tuple(...tuple1.elements, Schema.Boolean)
```

### Optional Elements

To define an optional element, wrap the schema of the element with the `optionalElement` constructor:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  Schema.String, // required element
  Schema.optionalElement(Schema.Number) // optional element
)
```

### Rest Element

To define rest elements, follow the list of elements (required or optional) with an element for the rest:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean // rest
)
```

Optionally, you can include other elements after the rest:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean, // rest
  Schema.String // additional element
)
```

### Exposed Values

You can access the elements and rest elements of a tuple schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean, // rest
  Schema.String // additional element
)

// Accesses the elements of the tuple
const tupleElements = schema.elements

// Accesses the rest elements of the tuple
const restElements = schema.rest
```

### Annotations

Annotations are used to add metadata to tuple elements, which can describe the purpose or requirements of each element more clearly. This can be particularly useful when generating documentation or JSON schemas from your schemas.

```ts twoslash
import { JSONSchema, Schema } from "@effect/schema"

// Defining a tuple with annotations for each coordinate in a point
const Point = Schema.Tuple(
  Schema.element(Schema.Number).annotations({
    title: "X",
    description: "X coordinate"
  }),
  Schema.optionalElement(Schema.Number).annotations({
    title: "Y",
    description: "optional Y coordinate"
  })
)

// Generating a JSON Schema from the tuple
console.log(JSONSchema.make(Point))
/*
Output:
{
  '$schema': 'http://json-schema.org/draft-07/schema#',
  type: 'array',
  minItems: 1,
  items: [
    { type: 'number', description: 'X coordinate', title: 'X' },
    {
      type: 'number',
      description: 'optional Y coordinate',
      title: 'Y'
    }
  ],
  additionalItems: false
}
*/
```

## Arrays

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Array(Schema.Number)
```

### Exposed Values

You can access the value of an array schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Array(Schema.String)

// Accesses the value
const value = schema.value // typeof Schema.String
```

### Mutable Arrays

By default, when you use `Schema.Array`, it generates a type marked as readonly. The `mutable` combinator is a useful function for creating a new schema with a mutable type in a **shallow** manner:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.mutable(Schema.Array(Schema.Number))
```

## Non empty arrays

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.NonEmptyArray(Schema.Number)
```

### Exposed Values

You can access the value of a non-empty array schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.NonEmptyArray(Schema.String)

// Accesses the value
const value = schema.value
```

## Records

### String Keyed Records

```ts twoslash
import { Schema } from "@effect/schema"

const opaque = Schema.Record({ key: Schema.String, value: Schema.Number })

// Schema<{ readonly [x: string]: number; }>
const schema = Schema.asSchema(opaque)
```

### Union of Literals as Keys

```ts twoslash
import { Schema } from "@effect/schema"

const opaque = Schema.Record({
  key: Schema.Union(Schema.Literal("a"), Schema.Literal("b")),
  value: Schema.Number
})

// Schema<{ readonly a: number; readonly b: number; }>
const schema = Schema.asSchema(opaque)
```

### Applying Key Refinements

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Record({
  key: Schema.String.pipe(Schema.minLength(2)),
  value: Schema.Number
})
```

### Symbol Keyed Records

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Record({
  key: Schema.SymbolFromSelf,
  value: Schema.Number
})
```

### Employing Template Literal Keys

```ts twoslash
import { Schema } from "@effect/schema"

const opaque = Schema.Record({
  key: Schema.TemplateLiteral(Schema.Literal("a"), Schema.String),
  value: Schema.Number
})

// Schema<{ readonly [x: `a${string}`]: number; }>
const schema = Schema.asSchema(opaque)
```

### Creating Mutable Records

By default, when you use `Schema.Record`, it generates a type marked as readonly. The `mutable` combinator is a useful function for creating a new schema with a mutable type in a **shallow** manner:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.mutable(
  Schema.Record({ key: Schema.String, value: Schema.Number })
)
```

### Exposed Values

You can access the key and the value of a record schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Record({ key: Schema.String, value: Schema.Number })

// Accesses the key
const key = schema.key

// Accesses the value
const value = schema.value
```
