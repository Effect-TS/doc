---
title: Basic Usage
excerpt: Basic Usage
bottomNavigation: pagination
---

## Cheatsheet

| Typescript Type                                           | Description / Notes                      | Schema / Combinator / Example                                              |
| --------------------------------------------------------- | ---------------------------------------- | -------------------------------------------------------------------------- |
| `null`                                                    |                                          | `S.Null`                                                                   |
| `undefined`                                               |                                          | `S.Undefined`                                                              |
| `string`                                                  |                                          | `S.String`                                                                 |
| `number`                                                  |                                          | `S.Number`                                                                 |
| `boolean`                                                 |                                          | `S.Boolean`                                                                |
| `symbol`                                                  |                                          | `S.SymbolFromSelf` / `S.Symbol`                                            |
| `BigInt`                                                  |                                          | `S.BigIntFromSelf` / `S.BigInt`                                            |
| `unknown`                                                 |                                          | `S.Unknown`                                                                |
| `any`                                                     |                                          | `S.Any`                                                                    |
| `never`                                                   |                                          | `S.Never`                                                                  |
| `object`                                                  |                                          | `S.Object`                                                                 |
| `unique symbol`                                           |                                          | `S.UniqueSymbolFromSelf`                                                   |
| `"a"`, `1`, `true`                                        | type literals                            | `S.Literal("a")`, `S.Literal(1)`, `S.Literal(true)`                        |
| `a${string}`                                              | template literals                        | `S.TemplateLiteral("a", S.String)`                                         |
| `{ readonly a: string, readonly b?: number\| undefined }` | structs                                  | `S.Struct({ a: S.String, b: S.optional(S.Number) })`                       |
| `Record<A, B>`                                            | records                                  | `S.Record({ key: A, value: B })`                                           |
| `readonly [string, number]`                               | tuples                                   | `S.Tuple(S.String, S.Number)`                                              |
| `ReadonlyArray<string>`                                   | arrays                                   | `S.Array(S.String)`                                                        |
| `A \| B`                                                  | unions                                   | `S.Union(A, B)`                                                            |
| `A & B`                                                   | intersections of non-overlapping structs | `S.extend(A, B)`                                                           |
| `Record<A, B> & Record<C, D>`                             | intersections of non-overlapping records | `S.extend(S.Record({ key: A, value: B }), S.Record({ key: C, value: D }))` |
| `type A = { a: A \| null }`                               | recursive types                          | `S.Struct({ a: S.Union(S.Null, S.suspend(() => self)) })`                  |
| `keyof A`                                                 |                                          | `S.keyof(A)`                                                               |
| `Partial<A>`                                              |                                          | `S.partial(A)`                                                             |
| `Required<A>`                                             |                                          | `S.required(A)`                                                            |

Here are the primitive schemas provided by the `@effect/schema/Schema` module:

## Primitives

These primitive schemas are building blocks for creating more complex schemas to describe your data structures.

```ts
import { Schema } from "@effect/schema"

Schema.String // Schema<string>
Schema.Number // Schema<number>
Schema.Boolean // Schema<boolean>
Schema.BigIntFromSelf // Schema<BigInt>
Schema.SymbolFromSelf // Schema<symbol>
Schema.Object // Schema<object>
Schema.Undefined // Schema<undefined>
Schema.Void // Schema<void>
Schema.Any // Schema<any>
Schema.Unknown // Schema<unknown>
Schema.Never // Schema<never>
```

## Literals

Literals represent specific values that are directly specified.

```ts
import { Schema } from "@effect/schema"

Schema.Null // same as S.Literal(null)
Schema.Literal("a")
Schema.Literal("a", "b", "c") // union of literals
Schema.Literal(1)
Schema.Literal(2n) // BigInt literal
Schema.Literal(true)
```

**Exposed Values**

You can access the literals of a literal schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Literal("a", "b")

// Accesses the literals
const literals = schema.literals
```

**The pickLiteral Utility**

We can also use `Schema.pickLiteral` with a literal schema to narrow down the possible values:

```ts twoslash
import { Schema } from "@effect/schema"

Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b")) // same as S.Literal("a", "b")
```

Sometimes, we need to reuse a schema literal in other parts of our code. Let's see an example:

```ts twoslash
import { Schema } from "@effect/schema"

const FruitId = Schema.Number
// the source of truth regarding the Fruit category
const FruitCategory = Schema.Literal("sweet", "citrus", "tropical")

const Fruit = Schema.Struct({
  id: FruitId,
  category: FruitCategory
})

// Here, we want to reuse our FruitCategory definition to create a subtype of Fruit
const SweetAndCitrusFruit = Schema.Struct({
  fruitId: FruitId,
  category: FruitCategory.pipe(Schema.pickLiteral("sweet", "citrus"))
  /*
    By using pickLiteral from the FruitCategory, we ensure that the values selected
    are those defined in the category definition above.
    If we remove "sweet" from the FruitCategory definition, TypeScript will notify us.
  */
})
```

In this example, `FruitCategory` serves as the source of truth for the categories of fruits. We reuse it to create a subtype of `Fruit` called `SweetAndCitrusFruit`, ensuring that only the categories defined in `FruitCategory` are allowed.

## Template literals

In TypeScript, template literals allow you to embed expressions within string literals.
The `Schema.TemplateLiteral` constructor allows you to create a schema for these template literal types.

Here's how you can use it:

```ts twoslash
import { Schema } from "@effect/schema"

// This creates a TemplateLiteral of type `a${string}`
Schema.TemplateLiteral("a", Schema.String)

// This creates a TemplateLiteral of type `https://${string}.com` or `https://${string}.net`
Schema.TemplateLiteral(
  "https://",
  Schema.String,
  ".",
  Schema.Literal("com", "net")
)
```

Let's look at a more complex example. Suppose you have two sets of locale IDs for emails and footers:

```ts twoslash
import { Schema } from "@effect/schema"

// example from https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
const EmailLocaleIDs = Schema.Literal("welcome_email", "email_heading")
const FooterLocaleIDs = Schema.Literal("footer_title", "footer_sendoff")
```

You can use the `Schema.TemplateLiteral` constructor to create a schema that combines these IDs:

```ts twoslash
import { Schema } from "@effect/schema"

const EmailLocaleIDs = Schema.Literal("welcome_email", "email_heading")
const FooterLocaleIDs = Schema.Literal("footer_title", "footer_sendoff")

// ---cut---
// This creates a TemplateLiteral of type "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
Schema.TemplateLiteral(Schema.Union(EmailLocaleIDs, FooterLocaleIDs), "_id")
```

The `Schema.TemplateLiteral` constructor supports the following types of spans:

- `Schema.String`
- `Schema.Number`
- Literals: `string | number | boolean | null | bigint`. These can be either wrapped by `Schema.Literal` or used directly
- Unions of the above types

## TemplateLiteralParser

The `Schema.TemplateLiteral` constructor, while useful as a simple validator, only verifies that an input conforms to a specific string pattern by converting template literal definitions into regular expressions. Similarly, `Schema.pattern` employs regular expressions directly for the same purpose. Post-validation, both methods require additional manual parsing to convert the validated string into a usable data format.

To address these limitations and eliminate the need for manual post-validation parsing, the new `TemplateLiteralParser` API has been developed. It not only validates the input format but also automatically parses it into a more structured and type-safe output, specifically into a **tuple** format.

This new approach enhances developer productivity by reducing boilerplate code and simplifying the process of working with complex string inputs.

**Example**

```ts twoslash
import { Schema } from "@effect/schema"

// const schema: Schema.Schema<readonly [number, "a", string], `${string}a${string}`, never>
const schema = Schema.TemplateLiteralParser(
  Schema.NumberFromString,
  "a",
  Schema.NonEmptyString
)

console.log(Schema.decodeEither(schema)("100afoo"))
// { _id: 'Either', _tag: 'Right', right: [ 100, 'a', 'foo' ] }

console.log(Schema.encode(schema)([100, "a", "foo"]))
// { _id: 'Either', _tag: 'Right', right: '100afoo' }
```

## Unique Symbols

```ts twoslash
import { Schema } from "@effect/schema"

const mySymbol = Symbol.for("mysymbol")

// const mySymbolSchema: S.Schema<typeof mySymbol>
const mySymbolSchema = Schema.UniqueSymbolFromSelf(mySymbol)
```

## Filters

Using the `Schema.filter` function, developers can define custom validation logic that goes beyond basic type checks, allowing for in-depth control over the data conformity process. This function applies a predicate to data, and if the data fails the predicate's condition, a custom error message can be returned.

<Info>
  For effectful filters, see
  [filterEffect](transformations#effectful-filters).
</Info>

**Example: Simple Validation**

```ts twoslash
import { Schema } from "@effect/schema"

const LongString = Schema.String.pipe(
  Schema.filter(
    (s) => s.length >= 10 || "a string at least 10 characters long"
  )
)

// string
type LongString = typeof LongString.Type

console.log(Schema.decodeUnknownSync(LongString)("a"))
/*
throws:
ParseError: { string | filter }
└─ Predicate refinement failure
   └─ a string at least 10 characters long
*/
```

<Info>
  Please note that the use of filters do not alter the `Type` of the schema.
  They only serve to add additional constraints to the parsing process. If you
  intend to modify the `Type`, consider using [Branded types](#branded-types).
</Info>

### Predicate Function Structure

The predicate for a filter is defined as follows:

```ts
type Predicate = (
  a: A,
  options: ParseOptions,
  self: AST.Refinement
) => FilterReturnType
```

where

```ts
interface FilterIssue {
  readonly path: ReadonlyArray<PropertyKey>
  readonly issue: string | ParseResult.ParseIssue
}

type FilterOutput =
  | undefined
  | boolean
  | string
  | ParseResult.ParseIssue
  | FilterIssue

type FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>
```

Filter predicates can return several types of values, each with specific implications:

- `true`: The data satisfies the filter's condition.
- `false` or `undefined`: The filter is not satisfied, and no specific error message is provided.
- `string`: The filter fails, and the provided string is used as the default error message.
- `ParseResult.ParseIssue`: The filter fails with a detailed error structure.
- `FilterIssue`: Allows specifying detailed error paths and messages, enhancing error specificity.

An array can be returned if multiple issues need to be reported, allowing for complex validations that may have multiple points of failure.

### Annotations

It's beneficial to embed as much metadata as possible within the schema. This metadata can include identifiers, JSON schema specifications, and descriptive text to facilitate later analysis and understanding of the schema's purpose and constraints.

**Example**

```ts twoslash
import { Schema } from "@effect/schema"

const LongString = Schema.String.pipe(
  Schema.filter(
    (s) =>
      s.length >= 10 ? undefined : "a string at least 10 characters long",
    {
      identifier: "LongString",
      jsonSchema: { minLength: 10 },
      description:
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua"
    }
  )
)

console.log(Schema.decodeUnknownSync(LongString)("a"))
/*
throws:
ParseError: { string | filter }
└─ Predicate refinement failure
   └─ a string at least 10 characters long
*/
```

### Specifying Error Paths

It's possible to specify an error path along with the message, which enhances error specificity and is particularly beneficial for integration with tools like [react-hook-form](https://react-hook-form.com/).

**Example**

```ts twoslash
import { ArrayFormatter, Schema } from "@effect/schema"
import { Either } from "effect"

const Password = Schema.Trim.pipe(Schema.minLength(1))

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password
}).pipe(
  Schema.filter((input) => {
    if (input.password !== input.confirm_password) {
      return {
        path: ["confirm_password"],
        message: "Passwords do not match"
      }
    }
  })
)

console.log(
  JSON.stringify(
    Schema.decodeUnknownEither(MyForm)({
      password: "abc",
      confirm_password: "d"
    }).pipe(Either.mapLeft((error) => ArrayFormatter.formatErrorSync(error))),
    null,
    2
  )
)
/*
  "_id": "Either",
  "_tag": "Left",
  "left": [
    {
      "_tag": "Type",
      "path": [
        "confirm_password"
      ],
      "message": "Passwords do not match"
    }
  ]
}
*/
```

This allows the error to be directly associated with the `confirm_password` field, improving clarity for the end-user.

<Info>
  The use of `ArrayFormatter` translates the error details into a more
  comprehensible format. For further details, see
  [ArrayFormatter](error-formatters#arrayformatter).
</Info>

### Multiple Error Reporting

The `Schema.filter` API also supports reporting multiple issues at once, which is useful in forms where several validation checks might fail simultaneously.

**Example**

```ts twoslash
import { ArrayFormatter, Schema } from "@effect/schema"
import { Either } from "effect"

const Password = Schema.Trim.pipe(Schema.minLength(1))
const OptionalString = Schema.optional(Schema.String)

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password,
  name: OptionalString,
  surname: OptionalString
}).pipe(
  Schema.filter((input) => {
    const issues: Array<Schema.FilterIssue> = []
    // passwords must match
    if (input.password !== input.confirm_password) {
      issues.push({
        path: ["confirm_password"],
        message: "Passwords do not match"
      })
    }
    // either name or surname must be present
    if (!input.name && !input.surname) {
      issues.push({
        path: ["surname"],
        message: "Surname must be present if name is not present"
      })
    }
    return issues
  })
)

console.log(
  JSON.stringify(
    Schema.decodeUnknownEither(MyForm)({
      password: "abc",
      confirm_password: "d"
    }).pipe(Either.mapLeft((error) => ArrayFormatter.formatErrorSync(error))),
    null,
    2
  )
)
/*
{
  "_id": "Either",
  "_tag": "Left",
  "left": [
    {
      "_tag": "Type",
      "path": [
        "confirm_password"
      ],
      "message": "Passwords do not match"
    },
    {
      "_tag": "Type",
      "path": [
        "surname"
      ],
      "message": "Surname must be present if name is not present"
    }
  ]
}
*/
```

<Info>
  The use of `ArrayFormatter` translates the error details into a more
  comprehensible format. For further details, see
  [ArrayFormatter](error-formatters#arrayformatter).
</Info>

### Exposed Values

You can access the base schema for which the filter has been defined:

```ts twoslash
import { Schema } from "@effect/schema"

const LongString = Schema.String.pipe(Schema.filter((s) => s.length >= 10))

// const From: typeof Schema.String
const From = LongString.from
```

In this example, you're able to access the original schema (`Schema.String`) for which the filter (`LongString`) has been defined. The `from` property provides access to this base schema.

### String Filters

```ts
import { Schema } from "@effect/schema"

// Specifies maximum length of a string
Schema.String.pipe(Schema.maxLength(5))

// Specifies minimum length of a string
Schema.String.pipe(Schema.minLength(5))

// Equivalent to ensuring the string has a minimum length of 1
Schema.NonEmptyString

// Specifies exact length of a string
Schema.String.pipe(Schema.length(5))

// Specifies a range for the length of a string
Schema.String.pipe(Schema.length({ min: 2, max: 4 }))

// Matches a string against a regular expression pattern
Schema.String.pipe(Schema.pattern(regex))

// Ensures a string starts with a specific substring
Schema.String.pipe(Schema.startsWith(string))

// Ensures a string ends with a specific substring
Schema.String.pipe(Schema.endsWith(string))

// Checks if a string includes a specific substring
Schema.String.pipe(Schema.includes(searchString))

// Validates that a string has no leading or trailing whitespaces
Schema.String.pipe(Schema.trimmed())

// Validates that a string is entirely in lowercase
Schema.String.pipe(Schema.lowercased())
```

<Info>
  The `trimmed` combinator does not make any transformations, it only
  validates. If what you were looking for was a combinator to trim strings,
  then check out the `trim` combinator ot the `Trim` schema.
</Info>

### Number Filters

```ts twoslash
import { Schema } from "@effect/schema"

// Specifies a number greater than 5
Schema.Number.pipe(Schema.greaterThan(5))

// Specifies a number greater than or equal to 5
Schema.Number.pipe(Schema.greaterThanOrEqualTo(5))

// Specifies a number less than 5
Schema.Number.pipe(Schema.lessThan(5))

// Specifies a number less than or equal to 5
Schema.Number.pipe(Schema.lessThanOrEqualTo(5))

// Specifies a number between -2 and 2, inclusive
Schema.Number.pipe(Schema.between(-2, 2))

// Specifies that the value must be an integer
Schema.Number.pipe(Schema.int())

// Ensures the value is not NaN
Schema.Number.pipe(Schema.nonNaN())

// Ensures the value is finite and not Infinity or -Infinity
Schema.Number.pipe(Schema.finite())

// Specifies a positive number (> 0)
Schema.Number.pipe(Schema.positive())

// Specifies a non-negative number (>= 0)
Schema.Number.pipe(Schema.nonNegative())

// Specifies a negative number (< 0)
Schema.Number.pipe(Schema.negative())

// Specifies a non-positive number (<= 0)
Schema.Number.pipe(Schema.nonPositive())

// Specifies a number that is evenly divisible by 5
Schema.Number.pipe(Schema.multipleOf(5))
```

### BigInt Filters

```ts
import { Schema } from "@effect/schema"

// Specifies a BigInt greater than 5
Schema.BigInt.pipe(Schema.greaterThanBigInt(5n))

// Specifies a BigInt greater than or equal to 5
Schema.BigInt.pipe(Schema.greaterThanOrEqualToBigInt(5n))

// Specifies a BigInt less than 5
Schema.BigInt.pipe(Schema.lessThanBigInt(5n))

// Specifies a BigInt less than or equal to 5
Schema.BigInt.pipe(Schema.lessThanOrEqualToBigInt(5n))

// Specifies a BigInt between -2 and 2, inclusive
Schema.BigInt.pipe(Schema.betweenBigInt(-2n, 2n))

// Specifies a positive BigInt (> 0n)
Schema.BigInt.pipe(Schema.positiveBigInt())

// Specifies a non-negative BigInt (>= 0n)
Schema.BigInt.pipe(Schema.nonNegativeBigInt())

// Specifies a negative BigInt (< 0n)
Schema.BigInt.pipe(Schema.negativeBigInt())

// Specifies a non-positive BigInt (<= 0n)
Schema.BigInt.pipe(Schema.nonPositiveBigInt())
```

### BigDecimal Filters

```ts twoslash
import { Schema } from "@effect/schema"
import { BigDecimal } from "effect"

// Specifies a BigDecimal greater than 5
Schema.BigDecimal.pipe(Schema.greaterThanBigDecimal(BigDecimal.fromNumber(5)))

// Specifies a BigDecimal greater than or equal to 5
Schema.BigDecimal.pipe(
  Schema.greaterThanOrEqualToBigDecimal(BigDecimal.fromNumber(5))
)
// Specifies a BigDecimal less than 5
Schema.BigDecimal.pipe(Schema.lessThanBigDecimal(BigDecimal.fromNumber(5)))

// Specifies a BigDecimal less than or equal to 5
Schema.BigDecimal.pipe(
  Schema.lessThanOrEqualToBigDecimal(BigDecimal.fromNumber(5))
)

// Specifies a BigDecimal between -2 and 2, inclusive
Schema.BigDecimal.pipe(
  Schema.betweenBigDecimal(
    BigDecimal.fromNumber(-2),
    BigDecimal.fromNumber(2)
  )
)

// Specifies a positive BigDecimal (> 0)
Schema.BigDecimal.pipe(Schema.positiveBigDecimal())

// Specifies a non-negative BigDecimal (>= 0)
Schema.BigDecimal.pipe(Schema.nonNegativeBigDecimal())

// Specifies a negative BigDecimal (< 0)
Schema.BigDecimal.pipe(Schema.negativeBigDecimal())

// Specifies a non-positive BigDecimal (<= 0)
Schema.BigDecimal.pipe(Schema.nonPositiveBigDecimal())
```

### Duration Filters

```ts twoslash
import { Schema } from "@effect/schema"

// Specifies a duration greater than 5 seconds
Schema.Duration.pipe(Schema.greaterThanDuration("5 seconds"))

// Specifies a duration greater than or equal to 5 seconds
Schema.Duration.pipe(Schema.greaterThanOrEqualToDuration("5 seconds"))

// Specifies a duration less than 5 seconds
Schema.Duration.pipe(Schema.lessThanDuration("5 seconds"))

// Specifies a duration less than or equal to 5 seconds
Schema.Duration.pipe(Schema.lessThanOrEqualToDuration("5 seconds"))

// Specifies a duration between 5 seconds and 10 seconds, inclusive
Schema.Duration.pipe(Schema.betweenDuration("5 seconds", "10 seconds"))
```

### Array Filters

```ts twoslash
import { Schema } from "@effect/schema"

// Specifies the maximum number of items in the array
Schema.Array(Schema.Number).pipe(Schema.maxItems(2))

// Specifies the minimum number of items in the array
Schema.Array(Schema.Number).pipe(Schema.minItems(2))

// Specifies the exact number of items in the array
Schema.Array(Schema.Number).pipe(Schema.itemsCount(2))
```

## Branded types

TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.
This can cause issues when types that are semantically different are treated as if they were the same.

```ts twoslash
type UserId = string
type Username = string

declare const getUser: (id: UserId) => object

const myUsername: Username = "gcanti"

getUser(myUsername) // This erroneously works
```

In the above example, `UserId` and `Username` are both aliases for the same type, `string`. This means that the `getUser` function can mistakenly accept a `Username` as a valid `UserId`, causing bugs and errors.

To avoid these kinds of issues, the Effect ecosystem provides a way to create custom types with a unique identifier attached to them. These are known as **branded types**.

```ts twoslash
// @errors: 2345
import { Brand } from "effect"

type UserId = string & Brand.Brand<"UserId">
type Username = string

declare const getUser: (id: UserId) => object

const myUsername: Username = "gcanti"

getUser(myUsername)
```

By defining `UserId` as a branded type, the `getUser` function can accept only values of type `UserId`, and not plain strings or other types that are compatible with strings. This helps to prevent bugs caused by accidentally passing the wrong type of value to the function.

There are two ways to define a schema for a branded type, depending on whether you:

- want to define the schema from scratch
- have already defined a [branded type](../style/branded-types) via `effect/Brand` and want to reuse it to define a schema

### Defining a brand schema from scratch

To define a schema for a branded type from scratch, you can use the `Schema.brand` function.

```ts twoslash
import { Schema } from "@effect/schema"

const UserId = Schema.String.pipe(Schema.brand("UserId"))

// string & Brand<"UserId">
type UserId = Schema.Schema.Type<typeof UserId>
```

Note that you can use `unique symbol`s as brands to ensure uniqueness across modules / packages:

```ts twoslash
import { Schema } from "@effect/schema"

const UserIdBrand = Symbol.for("UserId")

const UserId = Schema.String.pipe(Schema.brand(UserIdBrand))

// string & Brand<typeof UserIdBrand>
type UserId = Schema.Schema.Type<typeof UserId>
```

### Reusing an existing branded constructor

If you have already defined a [branded type](../style/branded-types) using the `effect/Brand` module, you can reuse it to define a schema using the `fromBrand` combinator exported by the `@effect/schema/Schema` module.

```ts twoslash
import { Schema } from "@effect/schema"
import { Brand } from "effect"

// the existing branded type
type UserId = string & Brand.Brand<"UserId">

const UserId = Brand.nominal<UserId>()

// Define a schema for the branded type
const UserIdSchema = Schema.String.pipe(Schema.fromBrand(UserId))
```

### Utilizing Default Constructors

The `Schema.brand` function includes a default constructor to facilitate the creation of branded values.

```ts twoslash
import { Schema } from "@effect/schema"

const UserId = Schema.String.pipe(Schema.brand("UserId"))

const userId = UserId.make("123") // Creates a branded UserId
```

## Native enums

```ts twoslash
import { Schema } from "@effect/schema"

enum Fruits {
  Apple,
  Banana
}

// Schema.Enums<typeof Fruits>
const schema = Schema.Enums(Fruits)
```

### Accessing Enum Members

Enums are exposed under an `enums` property of the schema:

```ts twoslash
import { Schema } from "@effect/schema"

enum Fruits {
  Apple,
  Banana
}

const schema = Schema.Enums(Fruits)

// ---cut---
// Access the enum members
schema.enums // Returns all enum members
schema.enums.Apple // Access the Apple member
schema.enums.Banana // Access the Banana member
```

## Unions

The Schema module includes a built-in `Union` constructor for composing "OR" types.

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Union(Schema.String, Schema.Number)
```

### Union of Literals

While the following is perfectly acceptable:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Union(
  Schema.Literal("a"),
  Schema.Literal("b"),
  Schema.Literal("c")
)
```

It is possible to use `Literal` and pass multiple literals, which is less cumbersome:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Literal("a", "b", "c")
```

### Nullables

```ts twoslash
import { Schema } from "@effect/schema"

// Represents a schema for a string or null value
Schema.NullOr(Schema.String)

// Represents a schema for a string, null, or undefined value
Schema.NullishOr(Schema.String)

// Represents a schema for a string or undefined value
Schema.UndefinedOr(Schema.String)
```

### Discriminated unions

TypeScript reference: https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions

Discriminated unions in TypeScript are a way of modeling complex data structures that may take on different forms based on a specific set of conditions or properties. They allow you to define a type that represents multiple related shapes, where each shape is uniquely identified by a shared discriminant property.

In a discriminated union, each variant of the union has a common property, called the discriminant. The discriminant is a literal type, which means it can only have a finite set of possible values. Based on the value of the discriminant property, TypeScript can infer which variant of the union is currently in use.

Here is an example of a discriminated union in TypeScript:

```ts twoslash
type Circle = {
  readonly kind: "circle"
  readonly radius: number
}

type Square = {
  readonly kind: "square"
  readonly sideLength: number
}

type Shape = Circle | Square
```

This code defines a discriminated union using the Schema module:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({
  kind: Schema.Literal("circle"),
  radius: Schema.Number
})

const Square = Schema.Struct({
  kind: Schema.Literal("square"),
  sideLength: Schema.Number
})

const Shape = Schema.Union(Circle, Square)
```

The `Literal` constructor is used to define the discriminant property with a specific string literal value.

Two structs are defined for `Circle` and `Square`, each with their own properties. These structs represent the variants of the union.

Finally, the `Union` constructor is used to create a schema for the discriminated union `Shape`, which is a union of `Circle` and `Square`.

### How to transform a simple union into a discriminated union

If you're working on a TypeScript project and you've defined a simple union to represent a particular input, you may find yourself in a situation where you're not entirely happy with how it's set up.
For example, let's say you've defined a `Shape` union as a combination of `Circle` and `Square` without any special property:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({
  radius: Schema.Number
})

const Square = Schema.Struct({
  sideLength: Schema.Number
})

const Shape = Schema.Union(Circle, Square)
```

To make your code more manageable, you may want to transform the simple union into a discriminated union. This way, TypeScript will be able to automatically determine which member of the union you're working with based on the value of a specific property.

To achieve this, you can add a special property to each member of the union, which will allow TypeScript to know which type it's dealing with at runtime.
Here's how you can [transform](transformations#transform) the `Shape` schema into another schema that represents a discriminated union:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({
  radius: Schema.Number
})

const Square = Schema.Struct({
  sideLength: Schema.Number
})

const DiscriminatedShape = Schema.Union(
  Schema.transform(
    Circle,
    Schema.Struct({ ...Circle.fields, kind: Schema.Literal("circle") }), // Add a "kind" property with the literal value "circle" to Circle
    {
      strict: true,
      decode: (circle) => ({ ...circle, kind: "circle" as const }), // Add the discriminant property to Circle
      encode: ({ kind: _kind, ...rest }) => rest // Remove the discriminant property
    }
  ),

  Schema.transform(
    Square,
    Schema.Struct({ ...Square.fields, kind: Schema.Literal("square") }), // Add a "kind" property with the literal value "square" to Square
    {
      strict: true,
      decode: (square) => ({ ...square, kind: "square" as const }), // Add the discriminant property to Square
      encode: ({ kind: _kind, ...rest }) => rest // Remove the discriminant property
    }
  )
)

console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ radius: 10 }))
// Output: { kind: 'circle', radius: 10 }

console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ sideLength: 10 }))
// Output: { kind: 'square', sideLength: 10 }
```

The previous solution works perfectly and shows how we can add properties to our schema at will, making it easier to consume the result within our domain model.
However, it requires a lot of boilerplate. Fortunately, there is an API called `Schema.attachPropertySignature` designed specifically for this use case, which allows us to achieve the same result with much less effort:

```ts twoslash
import { Schema } from "@effect/schema"

const Circle = Schema.Struct({ radius: Schema.Number })
const Square = Schema.Struct({ sideLength: Schema.Number })
const DiscriminatedShape = Schema.Union(
  Circle.pipe(Schema.attachPropertySignature("kind", "circle")),
  Square.pipe(Schema.attachPropertySignature("kind", "square"))
)

// decoding
console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ radius: 10 }))
// Output: { kind: 'circle', radius: 10 }

// encoding
console.log(
  Schema.encodeSync(DiscriminatedShape)({
    kind: "circle",
    radius: 10
  })
)
// Output: { radius: 10 }
```

<Warning>
  Please note that with `Schema.attachPropertySignature`, you can only add a
  property, it cannot override an existing one.
</Warning>

### Exposed Values

You can access the individual members of a union schema represented as a tuple:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Union(Schema.String, Schema.Number)

// Accesses the members of the union
const members = schema.members
```

## Tuples

### Required Elements

To define a tuple with required elements, you specify the list of elements:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(Schema.String, Schema.Number)
```

### Append a Required Element

```ts twoslash
import { Schema } from "@effect/schema"

const tuple1 = Schema.Tuple(Schema.String, Schema.Number)

const tuple2 = Schema.Tuple(...tuple1.elements, Schema.Boolean)
```

### Optional Elements

To define an optional element, wrap the schema of the element with the `optionalElement` constructor:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  Schema.String, // required element
  Schema.optionalElement(Schema.Number) // optional element
)
```

### Rest Element

To define rest elements, follow the list of elements (required or optional) with an element for the rest:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean // rest
)
```

Optionally, you can include other elements after the rest:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean, // rest
  Schema.String // additional element
)
```

### Exposed Values

You can access the elements and rest elements of a tuple schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean, // rest
  Schema.String // additional element
)

// Accesses the elements of the tuple
const tupleElements = schema.elements

// Accesses the rest elements of the tuple
const restElements = schema.rest
```

### Annotations

Annotations are used to add metadata to tuple elements, which can describe the purpose or requirements of each element more clearly. This can be particularly useful when generating documentation or JSON schemas from your schemas.

```ts twoslash
import { JSONSchema, Schema } from "@effect/schema"

// Defining a tuple with annotations for each coordinate in a point
const Point = Schema.Tuple(
  Schema.element(Schema.Number).annotations({
    title: "X",
    description: "X coordinate"
  }),
  Schema.optionalElement(Schema.Number).annotations({
    title: "Y",
    description: "optional Y coordinate"
  })
)

// Generating a JSON Schema from the tuple
console.log(JSONSchema.make(Point))
/*
Output:
{
  '$schema': 'http://json-schema.org/draft-07/schema#',
  type: 'array',
  minItems: 1,
  items: [
    { type: 'number', description: 'X coordinate', title: 'X' },
    {
      type: 'number',
      description: 'optional Y coordinate',
      title: 'Y'
    }
  ],
  additionalItems: false
}
*/
```

## Arrays

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Array(Schema.Number)
```

### Exposed Values

You can access the value of an array schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Array(Schema.String)

// Accesses the value
const value = schema.value // typeof Schema.String
```

### Mutable Arrays

By default, when you use `Schema.Array`, it generates a type marked as readonly. The `mutable` combinator is a useful function for creating a new schema with a mutable type in a **shallow** manner:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.mutable(Schema.Array(Schema.Number))
```

## Non empty arrays

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.NonEmptyArray(Schema.Number)
```

### Exposed Values

You can access the value of a non-empty array schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.NonEmptyArray(Schema.String)

// Accesses the value
const value = schema.value
```

## Records

### String Keyed Records

```ts twoslash
import { Schema } from "@effect/schema"

const opaque = Schema.Record({ key: Schema.String, value: Schema.Number })

// Schema<{ readonly [x: string]: number; }>
const schema = Schema.asSchema(opaque)
```

### Union of Literals as Keys

```ts twoslash
import { Schema } from "@effect/schema"

const opaque = Schema.Record({
  key: Schema.Union(Schema.Literal("a"), Schema.Literal("b")),
  value: Schema.Number
})

// Schema<{ readonly a: number; readonly b: number; }>
const schema = Schema.asSchema(opaque)
```

### Applying Key Refinements

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Record({
  key: Schema.String.pipe(Schema.minLength(2)),
  value: Schema.Number
})
```

### Symbol Keyed Records

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Record({
  key: Schema.SymbolFromSelf,
  value: Schema.Number
})
```

### Employing Template Literal Keys

```ts twoslash
import { Schema } from "@effect/schema"

const opaque = Schema.Record({
  key: Schema.TemplateLiteral(Schema.Literal("a"), Schema.String),
  value: Schema.Number
})

// Schema<{ readonly [x: `a${string}`]: number; }>
const schema = Schema.asSchema(opaque)
```

### Creating Mutable Records

By default, when you use `Schema.Record`, it generates a type marked as readonly. The `mutable` combinator is a useful function for creating a new schema with a mutable type in a **shallow** manner:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.mutable(
  Schema.Record({ key: Schema.String, value: Schema.Number })
)
```

### Exposed Values

You can access the key and the value of a record schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Record({ key: Schema.String, value: Schema.Number })

// Accesses the key
const key = schema.key

// Accesses the value
const value = schema.value
```

## Structs

Structs are used to define schemas for objects with specific properties. Here's how you can create and use a struct schema:

```ts twoslash
import { Schema } from "@effect/schema"

// Define a struct schema for an object with properties "name" (string) and "age" (number)
const MyStruct = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})
```

The `MyStruct` constant will have the type

```ts
const MyStruct: Schema.Struct<{
  name: typeof Schema.String
  age: typeof Schema.Number
}>
```

representing the structure of the object.

To view the detailed type of `MyStruct`, you can use the `Schema.asSchema` function:

```ts twoslash
import { Schema } from "@effect/schema"

const MyStruct = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// ---cut---
/*
const schema: Schema.Schema<{
    readonly name: string;
    readonly age: number;
}, {
    readonly name: string;
    readonly age: number;
}, never>
*/
const schema = Schema.asSchema(MyStruct)
```

<Warning>
  Note that `Schema.Struct({})` models the TypeScript type `{}`, which is
  similar to `unknown`. This means that the schema will allow any type of data
  to pass through without validation.
</Warning>

### Index Signatures

The `Struct` constructor optionally accepts a list of key/value pairs representing index signatures:

```ts
(props, ...indexSignatures) => Struct<...>
```

**Example**

```ts twoslash
import { Schema } from "@effect/schema"

/*
Schema.TypeLiteral<{
    a: typeof Schema.Number;
}, readonly [{
    readonly key: typeof Schema.String;
    readonly value: typeof Schema.Number;
}]>
*/
const opaque = Schema.Struct(
  {
    a: Schema.Number
  },
  { key: Schema.String, value: Schema.Number }
)

/*
Schema.Schema<{
    readonly [x: string]: number;
    readonly a: number;
}, {
    readonly [x: string]: number;
    readonly a: number;
}, never>
*/
const nonOpaque = Schema.asSchema(opaque)
```

Since the `Record` constructor returns a schema that exposes both the `key` and the `value`, instead of passing a bare object `{ key, value }`, you can use the `Record` constructor:

```ts twoslash
import { Schema } from "@effect/schema"

/*
Schema.TypeLiteral<{
    a: typeof Schema.Number;
}, readonly [Schema.Record$<typeof Schema.String, typeof Schema.Number>]>
*/
const opaque = Schema.Struct(
  { a: Schema.Number },
  Schema.Record({ key: Schema.String, value: Schema.Number })
)

/*
Schema.Schema<{
    readonly [x: string]: number;
    readonly a: number;
}, {
    readonly [x: string]: number;
    readonly a: number;
}, never>
*/
const nonOpaque = Schema.asSchema(opaque)
```

### Exposed Values

You can access the fields and the records of a struct schema:

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct(
  { a: Schema.Number },
  Schema.Record({ key: Schema.String, value: Schema.Number })
)

// Accesses the fields
const fields = schema.fields

// Accesses the records
const records = schema.records
```

### Mutable Properties

By default, when you use `Schema.Struct`, it generates a type with properties that are marked as readonly.
The `Schema.mutable` combinator is a useful function for creating a new schema with properties made mutable in a **shallow** manner:

```ts twoslash
import { Schema } from "@effect/schema"

const opaque = Schema.mutable(
  Schema.Struct({ a: Schema.String, b: Schema.Number })
)

/*
Schema.Schema<{
    a: string;
    b: number;
}, {
    a: string;
    b: number;
}, never>
*/
const nonOpaque = Schema.asSchema(opaque)
```

## Property Signatures

### Basic Usage of Property Signatures

A `PropertySignature` generally represents a transformation from a "From" field:

```ts
{
  fromKey: fromType
}
```

to a "To" field:

```ts
{
  toKey: toType
}
```

Let's start with the simple definition of a property signature that can be used to add annotations:

```ts twoslash
import { Schema } from "@effect/schema"

/*
Schema.Struct<{
    name: typeof Schema.String;
    age: Schema.propertySignature<typeof Schema.NumberFromString>;
}>
*/
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).annotations({
    title: "Age"
  })
})
```

Let's delve into the details of all the information contained in the type of a `PropertySignature`:

```ts
age: PropertySignature<
  ToToken,
  ToType,
  FromKey,
  FromToken,
  FromType,
  HasDefault,
  Context
>
```

| Param Name   | Description                                                                                                         |
| ------------ | ------------------------------------------------------------------------------------------------------------------- |
| `age`        | Key of the "To" field                                                                                               |
| `ToToken`    | Indicates field requirement: `"?:"` for optional, `":"` for required                                                |
| `ToType`     | Type of the "To" field                                                                                              |
| `FromKey`    | (Optional, default = `never`) Indicates the source field key, typically the same as "To" field key unless specified |
| `FormToken`  | Indicates source field requirement: `"?:"` for optional, `":"` for required                                         |
| `FromType`   | Type of the "From" field                                                                                            |
| `HasDefault` | Indicates if there is a constructor default value (Boolean)                                                         |

In our case, the type

```ts
PropertySignature<":", number, never, ":", string, false, never>
```

indicates that there is the following transformation:

| Param Name   | Description                                                                |
| ------------ | -------------------------------------------------------------------------- |
| `age`        | Key of the "To" field                                                      |
| `ToToken`    | `":"` indicates that the `age` field is required                           |
| `ToType`     | Type of the `age` field is `number`                                        |
| `FromKey`    | `never` indicates that the decoding occurs from the same field named `age` |
| `FormToken`  | `":"` indicates that the decoding occurs from a required `age` field       |
| `FromType`   | Type of the "From" field is `string`                                       |
| `HasDefault` | `false`: indicates there is no default value                               |

Now, suppose the field from which decoding occurs is named `"AGE"`, but for our model, we want to keep the name in lowercase `"age"`. To achieve this result, we need to map the field key from `"AGE"` to `"age"`, and to do that, we can use the `fromKey` combinator:

```ts twoslash
import { Schema } from "@effect/schema"

/*
Schema.Struct<{
    name: typeof Schema.String;
    age: Schema.PropertySignature<":", number, "AGE", ":", string, false, never>;
}>
*/
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).pipe(
    Schema.fromKey("AGE")
  )
})
```

This modification is represented in the type of the created `PropertySignature`:

```ts
// fromKey ----------------------v
PropertySignature<":", number, "AGE", ":", string, false, never>
```

Now, let's see an example of decoding:

```ts twoslash
import { Schema } from "@effect/schema"

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).pipe(
    Schema.fromKey("AGE")
  )
})

// ---cut---
console.log(Schema.decodeUnknownSync(Person)({ name: "name", AGE: "18" }))
// Output: { name: 'name', age: 18 }
```

### Optional Fields

**Basic Optional Property**

`Schema.optional(schema: Schema<A, I, R>)` defines a basic optional property that handles different inputs and outputs during decoding and encoding:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - Input `a: A` transforms back to `i: I`

**Optional with Nullability**

`Schema.optionalWith(schema: Schema<A, I, R>, { nullable: true })` allows handling of `null` values as equivalent to missing values:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - `null` transforms to `<missing value>`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - Input `a: A` transforms back to `i: I`

**Optional with Exactness**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true })` ensures that only the exact types specified are handled, excluding `undefined`:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - Input `a: A` transforms back to `i: I`

**Combining Nullability and Exactness**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true, nullable: true })` combines handling for exact types and null values:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - `null` transforms to `<missing value>`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - Input `a: A` transforms back to `i: I`

### Representing Optional Fields with never Type

When defining types in TypeScript that include optional fields with the type `never`, such as:

```ts
type A = {
  readonly a?: never
}
```

the approach varies based on the `exactOptionalPropertyTypes` configuration in your `tsconfig.json`

**TypeScript Configuration: `exactOptionalPropertyTypes = false`**

When this setting is disabled, optional fields are best handled by explicitly defining them as `undefined`. This reflects that the field may not be present, and if it is, it holds no value.

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  a: Schema.optional(Schema.Undefined)
})
```

**TypeScript Configuration: `exactOptionalPropertyTypes = true`**

With `exactOptionalPropertyTypes` enabled, the definition changes slightly to enforce the field's absence more strictly. This configuration is more precise and aligns with newer TypeScript strictness features.

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  a: Schema.optionalWith(Schema.Never, { exact: true })
})
```

### Default Values

The `default` option in schemas allows you to set default values that are applied during both decoding and object construction phases. This feature ensures that even if certain properties are not provided by the user, the system will automatically use the specified default values.

**Example**

Let's see how default values work in both the decoding and constructing phases, illustrating how the default value is applied when certain properties are not provided.

```ts twoslash
import { Schema } from "@effect/schema"

const Product = Schema.Struct({
  name: Schema.String,
  price: Schema.NumberFromString,
  quantity: Schema.optionalWith(Schema.NumberFromString, { default: () => 1 })
})

// Applying defaults in the decoding phase

console.log(
  Schema.decodeUnknownSync(Product)({ name: "Laptop", price: "999" })
)
// Output: { name: 'Laptop', price: 999, quantity: 1 }

console.log(
  Schema.decodeUnknownSync(Product)({
    name: "Laptop",
    price: "999",
    quantity: "2"
  })
)
// Output: { name: 'Laptop', price: 999, quantity: 2 }

// Applying defaults in the constructor

console.log(Product.make({ name: "Laptop", price: 999 }))
// Output: { name: 'Laptop', price: 999, quantity: 1 }

console.log(Product.make({ name: "Laptop", price: 999, quantity: 2 }))
// Output: { name: 'Laptop', price: 999, quantity: 2 }
```

`Schema.optionalWith` can be configured with additional options to handle decoding and encoding precisely:

**Basic Optional with Default**

`Schema.optionalWith(schema: Schema<A, I, R>, { default: () => A })`

- **Decoding:** Translates missing or undefined inputs to a default value.
- **Encoding:** Input `a: A` transforms back to `i: I`

**Optional with Exactness**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true, default: () => A })`

- **Decoding:** Applies the default value only if the input is missing.
- **Encoding:** Input `a: A` transforms back to `i: I`

**Optional with Nullability**

`Schema.optionalWith(schema: Schema<A, I, R>, { nullable: true, default: () => A })`

- **Decoding:** Treats null, undefined, or missing inputs as defaults.
- **Encoding:** Input `a: A` transforms back to `i: I`

**Combining Exactness and Nullability**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true, nullable: true, default: () => A })`

- **Decoding:** Defaults are applied when values are null or missing.
- **Encoding:** Input `a: A` transforms back to `i: I`

### Optional Fields as Options

**Basic Optional with Option Type**

`optionalWith(schema: Schema<A, I, R>, { as: "Option" })`

- **Decoding:**
  - Missing values or `undefined` are converted to `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a: A)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

**Optional with Exactness**

`optionalWith(schema: Schema<A, I, R>, { exact: true, as: "Option" })`

- **Decoding:**
  - Only truly missing values are converted to `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

**Optional with Nullability**

`optionalWith(schema: Schema<A, I, R>, { nullable: true, as: "Option" })`

- **Decoding:**
  - Treats missing, `undefined`, and `null` values all as `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a: A)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

**Combining Exactness and Nullability**

`optionalWith(schema: Schema<A, I, R>, { exact: true, nullable: true, as: "Option" })`

- **Decoding:**
  - Missing or `null` values lead to `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a: A)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

## Optional Fields Primitives

The `Schema.optional` and `Schema.optionalWith` functions are built on two foundational operations: `Schema.optionalToOptional` and `Schema.optionalToRequired`.
These functions provide nuanced control over how optional fields are handled in your schemas, allowing for precise property signatures.

### optionalToOptional

The `Schema.optionalToOptional` API is used to manage the transformation from an optional field to another optional field.
With this, we can control both the output type and the presence or absence of the field.

For example a common use case is to equate a specific value in the source field with the absence of value in the destination field.

Here's the signature of the `optionalToOptional` API:

```ts
export const optionalToOptional = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: Option.Option<FA>) => Option.Option<TI>,
    readonly encode: (o: Option.Option<TI>) => Option.Option<FA>
  }
): PropertySignature<"?:", TA, never, "?:", FI, false, FR | TR>
```

As you can see, we can transform the type by specifying a schema for `to`, which can be different from the schema of `from`.
Additionally, we can control the presence or absence of the field using `decode` and `encode`, with the following meanings:

- `Option.none()` as an argument means the value is missing in the input
- `Option.none()` as a return value means the value will be missing in the output

**Example**

Suppose we have an optional field of type `string`, and we want to exclude empty strings from the output. In other words, if the input contains an empty string, we want the field to be absent in the output.

```ts twoslash
import { Schema } from "@effect/schema"
import { identity, Option } from "effect"

const schema = Schema.Struct({
  a: Schema.optionalToOptional(Schema.String, Schema.String, {
    decode: (input) => {
      if (Option.isNone(input)) {
        // If the field is absent in the input, returning `Option.none()` will make it absent in the output too
        return Option.none()
      }
      const value = input.value
      if (value === "") {
        // If the field is present in the input but is an empty string, returning `Option.none()` will make it absent in the output
        return Option.none()
      }
      // If the field is present in the input and is not an empty string, returning `Option.some` will make it present in the output
      return Option.some(value)
    },
    // Here in the encoding part, we can decide to handle things in the same way as in the decoding phase
    // or handle them differently. For example, we can leave everything unchanged and use the identity function
    encode: identity
  })
})

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({})) // Output: {}
console.log(decode({ a: "" })) // Output: {}
console.log(decode({ a: "a non-empty string" })) // Output: { a: 'a non-empty string' }

const encode = Schema.encodeSync(schema)

console.log(encode({})) // Output: {}
console.log(encode({ a: "" })) // Output: { a: '' }
console.log(encode({ a: "foo" })) // Output: { a: 'foo' }
```

### optionalToRequired

The `Schema.optionalToRequired` API allows us to transform an optional field into a required one, applying custom logic if the field is absent in the input.

```ts
export const optionalToRequired = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: Option.Option<FA>) => TI,
    readonly encode: (ti: TI) => Option.Option<FA>
  }
): PropertySignature<":", TA, never, "?:", FI, false, FR | TR>
```

We can control the presence or absence of the field using `decode` and `encode`, with the following meanings:

- `Option.none()` as an argument means the value is missing in the input
- `Option.none()` as a return value means the value will be missing in the output

**Example**

For instance, a common use case is to assign a default value to the field in the output if it's missing in the input.

```ts twoslash
import { Schema } from "@effect/schema"
import { Option } from "effect"

const schema = Schema.Struct({
  a: Schema.optionalToRequired(Schema.String, Schema.String, {
    decode: (input) => {
      if (Option.isNone(input)) {
        // If the field is absent in the input, we can return the default value for the field in the output
        return "default value"
      }
      // If the field is present in the input, return its value as it is in the output
      return input.value
    },
    // During encoding, we can choose to handle things differently, or simply return the same value present in the input for the output
    encode: (a) => Option.some(a)
  })
})

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({})) // Output: { a: 'default value' }
console.log(decode({ a: "foo" })) // Output: { a: 'foo' }

const encode = Schema.encodeSync(schema)

console.log(encode({ a: "foo" })) // Output: { a: 'foo' }
```

### requiredToOptional

This API allows developers to specify how a field that is normally required can be treated as optional based on custom logic.

```ts
export const requiredToOptional = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (fa: FA) => Option.Option<TI>
    readonly encode: (o: Option.Option<TI>) => FA
  }
): PropertySignature<"?:", TA, never, ":", FI, false, FR | TR>
```

We can control the presence or absence of the field using `decode` and `encode`, with the following meanings:

- `Option.none()` as an argument means the value is missing in the input
- `Option.none()` as a return value means the value will be missing in the output

**Example**

Let's look at a practical example where a field `name` that is typically required can be considered optional if it's an empty string during decoding, and ensure there is always a value during encoding by providing a default.

```ts twoslash
import { Schema } from "@effect/schema"
import { Option } from "effect"

const schema = Schema.Struct({
  name: Schema.requiredToOptional(Schema.String, Schema.String, {
    decode: Option.liftPredicate((s) => s !== ""), // empty string is considered as absent
    encode: Option.getOrElse(() => "")
  })
})

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({ name: "John" })) // Output: { name: 'John' }
console.log(decode({ name: "" })) // Output: {}

const encode = Schema.encodeSync(schema)

console.log(encode({ name: "John" })) // { name: 'John' }
console.log(encode({})) // Output: { name: '' }
```

## Renaming Properties

### Renaming a Property During Definition

To rename a property directly during schema creation, you can utilize the `Schema.fromKey` function. This function is particularly useful when you want to map properties from the input object to different names in the resulting schema object.

**Example: Renaming a Required Property**

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  a: Schema.propertySignature(Schema.String).pipe(Schema.fromKey("c")),
  b: Schema.Number
})

console.log(Schema.decodeUnknownSync(schema)({ c: "c", b: 1 }))
// Output: { a: "c", b: 1 }
```

**Example: Renaming an Optional Property**

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  a: Schema.optional(Schema.String).pipe(Schema.fromKey("c")),
  b: Schema.Number
})

console.log(Schema.decodeUnknownSync(schema)({ c: "c", b: 1 }))
// Output: { b: 1, a: "c" }

console.log(Schema.decodeUnknownSync(schema)({ b: 1 }))
// Output: { b: 1 }
```

Note that `Schema.optional` returns a `PropertySignature`, which simplifies the process by eliminating the need for explicit `Schema.propertySignature` usage as required in the previous example.

### Renaming Properties of an Existing Schema

For existing schemas, the `rename` API offers a way to systematically change property names across a schema, even within complex structures like unions.

**Example: Renaming Properties in a Struct Schema**

```ts twoslash
import { Schema } from "@effect/schema"

// Original Schema
const originalSchema = Schema.Struct({
  c: Schema.String,
  b: Schema.Number
})

// Renaming the "c" property to "a"
const renamedSchema = Schema.rename(originalSchema, { c: "a" })

console.log(Schema.decodeUnknownSync(renamedSchema)({ c: "c", b: 1 }))
// Output: { a: "c", b: 1 }
```

**Example: Renaming Properties in Union Schemas**

```ts twoslash
import { Schema } from "@effect/schema"

const originalSchema = Schema.Union(
  Schema.Struct({
    c: Schema.String,
    b: Schema.Number
  }),
  Schema.Struct({
    c: Schema.String,
    d: Schema.Boolean
  })
)

// Renaming the "c" property to "a" for all members
const renamedSchema = Schema.rename(originalSchema, { c: "a" })

console.log(Schema.decodeUnknownSync(renamedSchema)({ c: "c", b: 1 }))
// Output: { a: "c", b: 1 }

console.log(Schema.decodeUnknownSync(renamedSchema)({ c: "c", d: false }))
// Output: { d: false, a: 'c' }
```

## Tagged Structs

In TypeScript tags help to enhance type discrimination and pattern matching by providing a simple yet powerful way to define and recognize different data types.

### What is a Tag?

A tag is a literal value added to data structures, commonly used in structs, to distinguish between various object types or variants within tagged unions. This literal acts as a discriminator, making it easier to handle and process different types of data correctly and efficiently.

### Using the tag Constructor

The `tag` constructor is specifically designed to create a property signature that holds a specific literal value, serving as the discriminator for object types. Here's how you can define a schema with a tag:

```ts twoslash
import { Schema } from "@effect/schema"

const User = Schema.Struct({
  _tag: Schema.tag("User"),
  name: Schema.String,
  age: Schema.Number
})

console.log(User.make({ name: "John", age: 44 }))
/*
Output:
{ _tag: 'User', name: 'John', age: 44 }
*/
```

In the example above, `Schema.tag("User")` attaches a `_tag` property to the `User` struct schema, effectively labeling objects of this struct type as "User". This label is automatically applied when using the `make` method to create new instances, simplifying object creation and ensuring consistent tagging.

### Simplifying Tagged Structs with TaggedStruct

The `TaggedStruct` constructor streamlines the process of creating tagged structs by directly integrating the tag into the struct definition. This method provides a clearer and more declarative approach to building data structures with embedded discriminators.

```ts twoslash
import { Schema } from "@effect/schema"

const User = Schema.TaggedStruct("User", {
  name: Schema.String,
  age: Schema.Number
})

// `_tag` is optional
const userInstance = User.make({ name: "John", age: 44 })

console.log(userInstance)
/*
Output:
{ _tag: 'User', name: 'John', age: 44 }
*/
```

### Multiple Tags

While a primary tag is often sufficient, TypeScript allows you to define multiple tags for more complex data structuring needs. Here's an example demonstrating the use of multiple tags within a single struct:

```ts twoslash
import { Schema } from "@effect/schema"

const Product = Schema.TaggedStruct("Product", {
  category: Schema.tag("Electronics"),
  name: Schema.String,
  price: Schema.Number
})

// `_tag` and `category` are optional
const productInstance = Product.make({ name: "Smartphone", price: 999 })

console.log(productInstance)
/*
Output:
{
  _tag: 'Product',
  category: 'Electronics',
  name: 'Smartphone',
  price: 999
}
*/
```

This example showcases a product schema that not only categorizes each product under a general tag (`"Product"`) but also specifies a category tag (`"Electronics"`), enhancing the clarity and specificity of the data model.
