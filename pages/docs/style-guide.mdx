import { Callout } from "nextra-theme-docs"

# Style Guide

Effect style guide is a set of recommendations for writing Effect modules.

## Modules

Effect ecosystem consists of many modules. Always use **`import * as ...`**
to avoid name conflicts. Modules are like namespaces.

```ts
import * as Effect from "@effect/io/Effect"
import * as Either from "@effect/data/Either"
import * as Schema from "@effect/schema/Schema"

// Effect.runCallback
// Either.fromNullable
// Schema.struct
```

Types and interfaces should be "namespaced" as well. You may think it's
verbose, but it's explicit, and the code written in this style will never clash.

```
Effect.Effect<SomeRequirement, SomeError, SomeResult>
```

There is only one exception. Functions from module Function shall be used directly.

```ts
import { pipe } from "@effect/data/Function"
```

## Writing Code with Effect

Nested callbacks are a common problem in JavaScript, and are often handled by using async/await in most modern JavaScript codebases. However, since we are working in the world of Effects, the available APIs are a bit different.

This section will cover the three common ways to organize Effectful code:

1. Using the pipeable API
2. Using Generators
3. Using the `Do` simulation

### 1. Using the pipeable API

The pipe function is a common way to organize Effectful code. It is a function that takes a value and a list of functions, and applies the functions to the value in order.

The pipe function is defined in the Effect library, and is available in the Effect namespace.

```ts twoslash
import { pipe } from "@effect/data/Function"
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"

const example = pipe(
  Random.next(),
  Effect.flatMap((n) =>
    n > 0.5 ? Effect.succeed("yay!") : Effect.fail("oh no!")
  )
)
```

Here, Random.next() is getting piped as an argument to `Effect.flatMap`.

<Callout>
  Many functions in Effect have `dual` APIs, which means that you can either
  call it `data-first` or `data-last`. Here, you can see how `Effect.flatMap`
  was already defined, so `Random.next()` is passed in last. Similarly, you can
  also call `Effect.flatMap(Random.next(), (n) => ...)` with `Random.next()` and
  without `pipe` to get the same result.
</Callout>

### 2. Using Generators

Effect has a unique imperative API to solve for the problem of lots of nested callbacks when using functions like `pipe`. Instead of writing the code above, here's what it would look like if you were to write the same thing with the generator API.

```ts twoslash
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"

const example = Effect.gen(function* ($) {
  const n = yield* $(Random.next())
  if (n > 0.5) {
    return yield* $(Effect.succeed("yay!"))
  } else {
    return yield* $(Effect.fail("oh no!"))
  }
})
```

Note all the asterisks and dollar signs. The `*` is used to denote a generator, and the `$` function which is passed in as an argument to `Effect.gen` must follow `yield*` if you are yielding an Effect.

This way, you can write in a more imperative style rather than having to use `pipe` and `flatMap`.

<Callout type="info">
  The `$` argument can actually also be used as a `pipe`. For example, you could
  pipe `Random.next()` into something else before yielding.
</Callout>

### 3. Using the `Do` Simulation

To avoid nested pipes and generators, Effect has a `Do` function which can be used to simulate `Do` notation in other languages.

<Callout type="info">
  If you are familiar with Haskell or Scala, you may be familiar with `Do`
  notation or Scala's `for` comprehensions. Effect has a similar API.
</Callout>

Here's what a slightly more complex version of the above example would look like if you were to use the `Do` function.

```ts twoslash
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"
import { pipe } from "@effect/data/Function"

const example = pipe(
  Effect.Do(),
  Effect.let("randomValue", () => 3),
  Effect.bind("randomNumber", ({ randomValue }) =>
    randomValue > 2 ? Random.next() : Random.next()
  ),
  Effect.map(({ randomNumber, randomValue }) =>
    randomNumber > 0.5 && randomValue > 1
      ? Effect.succeed("yay!")
      : Effect.fail("oh no!")
  )
)
```

<Callout type="info">
  Using `Effect.let` is similar to saving a variable to a value, while
  `Effect.bind` will unwrap an Effect similar to `Effect.flatMap`.
</Callout>

The strings passed to `bind` become keys in an object, and the values being the result on the right. When using these functions, notice how each successive function is passed the previous result, similar to if you had set a variable in the generator example above.

## Errors

Define errors with `Error` suffix.

TODO:
