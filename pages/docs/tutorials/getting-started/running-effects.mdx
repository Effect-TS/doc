import { Callout } from "nextra-theme-docs"

# Running Effects

To execute an `Effect`, we can utilize a variety of `run*` functions provided by the `Effect` module.

## runSync

The `runSync` function is used to execute an Effect synchronously, which means it runs immediately and returns the result.
It is useful when your effect does not involve any asynchronous tasks and you need the result immediately.

```ts
import * as Effect from "@effect/io/Effect"

const program: Effect.Effect<never, never, number> = Effect.sync(() => {
  console.log("Hello, World!")
  return 42
})

const result: number = Effect.runSync(program)
```

If you check the console, you will see the message `"Hello, World!"` printed.

<Callout type="warning">
  `runSync` should only be used if your Effect doesn't fail and doesn't perform
  any asynchronous tasks
</Callout>

## runSyncEither

The `runSyncEither` function is used to execute an Effect synchronously, which means it runs immediately and returns the result as an `Either`
(a data type used to represent the possibility of either a successful value or a failure value).
It is useful when your effect does not involve any asynchronous tasks and you need to handle both the success or failure outcomes.

```ts
import * as Effect from "@effect/io/Effect"
import * as Either from "@effect/data/Either"

const program: Effect.Effect<never, Error, any> = Effect.tryCatch(
  () => JSON.parse(""), // JSON.parse may throw for bad input
  (e) => new Error(`something went wrong ${e}`) // remap the error
)

const result: Either.Either<Error, any> = Effect.runSyncEither(program)
```

<Callout type="warning">
  `runSyncEither` should only be used if your Effect doesn't perform any
  asynchronous tasks
</Callout>

## runPromise

The `runPromise` function is used to execute an Effect and obtain the result as a `Promise`.
It is useful when your effect involves asynchronous tasks and you want to work with the result using `Promise`-based APIs.

```ts
import * as Effect from "@effect/io/Effect"

const program: Effect.Effect<never, never, number> = Effect.promise(() =>
  Promise.resolve(42)
)

const result: Promise<string> = Effect.runPromise(program)
```

<Callout type="warning">
  `runPromise` should only be used if your Effect doesn't fail
</Callout>

## runPromiseEither

The `runPromiseEither` function is used to execute an Effect and obtain the result as a `Promise` that resolves to an `Either`
(a data type used to represent the possibility of either a successful value or a failure value).
It is useful when you need to handle both the success or failure outcomes.

```ts
import * as Effect from "@effect/io/Effect"
import * as Either from "@effect/data/Either"

const result: Promise<Either.Either<never, string>> = Effect.runPromiseEither(
  Effect.succeed("Hello, World!")
)
```

## Design principles

The recommended approach is to design your program with the majority of its logic as Effects. It's advisable to use the `run` functions closer to the "edge" of your program. This approach allows for greater flexibility in executing your program and building sophisticated Effects.

## Cheatsheet

The table provides a summary of the available `run*` functions, along with their input and output types, allowing you to choose the appropriate function based on your needs.

| **Name**           | **Given**             | **To**                  |
| ------------------ | --------------------- | ----------------------- |
| `runSync`          | `Effect<never, E, A>` | `A`                     |
| `runSyncEither`    | `Effect<never, E, A>` | `Either<E, A>`          |
| `runPromise`       | `Effect<never, E, A>` | `Promise<A>`            |
| `runPromiseEither` | `Effect<never, E, A>` | `Promise<Either<E, A>>` |

You can find the complete list of `run*` functions [here](https://effect-ts.github.io/io/modules/Effect.ts.html#execution).

## What to read next

In the next tutorial, we will learn how to build more complex programs by creating **pipelines**.
Check out the next tutorial on [Build a pipeline](pipeline) to find out more.
