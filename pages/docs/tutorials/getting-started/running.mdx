import { Design, Warning } from "@/components/Callout"

# Running Effects

To execute an `Effect`, we can utilize a variety of `run*` functions provided by the `Effect` module.

## runSync

The `runSync` function is used to execute an Effect synchronously, which means it runs immediately and returns the result.

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"

const program = Effect.sync(() => {
  console.log("Hello, World!")
  return 1
})

assert.strictEqual(Effect.runSync(program), 1)
```

If you check the console, you will see the message `"Hello, World!"` printed.

<Warning>
  `runSync` will throw an error if your Effect fails or performs any
  asynchronous tasks
</Warning>

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"

assert.throws(() => Effect.runSync(Effect.fail("error")))

assert.throws(() => Effect.runSync(Effect.promise(() => Promise.resolve(1))))
```

## runSyncEither

The `runSyncEither` function is used to execute an Effect synchronously, which means it runs immediately and returns the result as an `Either`
(a data type used to represent the possibility of either a successful value or a failure value).
It is useful when your effect does not involve any asynchronous tasks and you need to handle both the success or failure outcomes.

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"
import * as Either from "@effect/data/Either"

assert.deepStrictEqual(Effect.runSyncEither(Effect.succeed(1)), Either.right(1))

assert.deepStrictEqual(
  Effect.runSyncEither(Effect.fail("error")),
  Either.left("error")
)
```

<Warning>
  `runSyncEither` will throw an error if your Effect performs any asynchronous
  tasks
</Warning>

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"

assert.throws(() =>
  Effect.runSyncEither(Effect.promise(() => Promise.resolve(1)))
)
```

## runSyncExit

The `runSyncExit` function is used to execute an Effect synchronously, which means it runs immediately and returns the result as an `Exit`
(a data type used to represent the possibility of either a successful value or a failure value).
It is useful when your effect does not involve any asynchronous tasks and you need to handle both the success or failure outcomes.

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"
import * as Exit from "@effect/io/Exit"

assert.deepStrictEqual(Effect.runSyncExit(Effect.succeed(1)), Exit.succeed(1))

assert.ok(Exit.isFailure(Effect.runSyncExit(Effect.fail("error"))))
```

<Warning>
  `runSyncExit` will throw an error if your Effect performs any asynchronous
  tasks
</Warning>

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"

assert.throws(() =>
  Effect.runSyncExit(Effect.promise(() => Promise.resolve(1)))
)
```

## runPromise

The `runPromise` function is used to execute an Effect and obtain the result as a `Promise`.

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"

const run = async () =>
  assert.deepStrictEqual(await Effect.runPromise(Effect.succeed(1)), 1)

run()
```

<Warning>`runPromise` will reject with an error if your Effect fails</Warning>

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"

assert.rejects(() => Effect.runPromise(Effect.fail("error")))
```

## runPromiseEither

The `runPromiseEither` function is used to execute an Effect and obtain the result as a `Promise` that resolves to an `Either`
(a data type used to represent the possibility of either a successful value or a failure value).
It is useful when you need to handle both the success or failure outcomes.

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"
import * as Either from "@effect/data/Either"

const run = async () => {
  assert.deepStrictEqual(
    await Effect.runPromiseEither(Effect.succeed(1)),
    Either.right(1)
  )

  assert.deepStrictEqual(
    await Effect.runPromiseEither(Effect.fail("error")),
    Either.left("error")
  )
}

run()
```

## runPromiseExit

The `runPromiseExit` function is used to execute an Effect and obtain the result as a `Promise` that resolves to an `Exit`
(a data type used to represent the possibility of either a successful value or a failure value).
It is useful when you need to handle both the success or failure outcomes.

```ts
import * as assert from "node:assert"
import * as Effect from "@effect/io/Effect"
import * as Exit from "@effect/io/Exit"

const run = async () => {
  assert.deepStrictEqual(
    await Effect.runPromiseExit(Effect.succeed(1)),
    Exit.succeed(1)
  )

  assert.ok(Exit.isFailure(await Effect.runPromiseExit(Effect.fail("error"))))
}

run()
```

## Cheatsheet

<Design>
  The recommended approach is to design your program with the majority of its
  logic as Effects. It's advisable to use the `run*` functions closer to the
  "edge" of your program. This approach allows for greater flexibility in
  executing your program and building sophisticated Effects.
</Design>

The table provides a summary of the available `run*` functions, along with their input and output types, allowing you to choose the appropriate function based on your needs.

| **Name**           | **Given**             | **To**                  |
| ------------------ | --------------------- | ----------------------- |
| `runSync`          | `Effect<never, E, A>` | `A`                     |
| `runSyncEither`    | `Effect<never, E, A>` | `Either<E, A>`          |
| `runSyncExit`      | `Effect<never, E, A>` | `Exit<E, A>`            |
| `runPromise`       | `Effect<never, E, A>` | `Promise<A>`            |
| `runPromiseEither` | `Effect<never, E, A>` | `Promise<Either<E, A>>` |
| `runPromiseExit`   | `Effect<never, E, A>` | `Promise<Exit<E, A>>`   |

You can find the complete list of `run*` functions [here](https://effect-ts.github.io/io/modules/Effect.ts.html#execution).

---

**What to read next**

In the next tutorial, we will learn how to build more complex programs by creating **pipelines**.
Check out the next tutorial on [Build a pipeline](pipeline) to find out more.
