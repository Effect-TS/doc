import { Callout, Cards, Card } from "nextra-theme-docs"

# Create your first Effect

Effect provides different ways to create effects. In this tutorial, we will cover some of the common ones that you can use.

## Creating an Effect from a value

To create an `Effect` from a value, you can use the `succeed` constructor:

```ts twoslash
import * as Effect from "@effect/io/Effect"

const fromValue = Effect.succeed("Hello, World!")
```

By inspecting the type of `fromValue` we can see that it is:

```ts
//       ①     ②      ③
Effect<never, never, string>

/*
① = the context channel
② = the error channel
③ = the success channel
*/
```

The type `Effect<never, never, string>` can be interpreted as an Effect that:

- does not require any context (type `never`)
- does not produce any expected error (type `never`)
- succeeds with a value of type `string`

## Creating an Effect from a "thunk"

In JavaScript, you can defer a synchronous computation using a "thunk".

<Callout type="info">
A "thunk" is a function that takes no arguments and may return some value, for example:

`const myThunk = () => 42{:ts}`.

</Callout>

Thunks are useful for delaying the computation of a value until it is needed.

You can create an `Effect` from a thunk using the `sync` constructor:

```ts
import * as Effect from "@effect/io/Effect"

const logHelloWorld = Effect.sync(() => {
  console.log("Hello, World!")
  return 42
})
```

In the above example, `Effect.sync` is used to defer the side-effect of writing to the console.
The created Effect has the type `Effect<never, never, number>` because the thunk returns the value `42`.

Note that nothing is logged to the console yet when you inspect it.
This is because `logHelloWorld` represents the action of writing to the console, but nothing happens until you explicitly run your program.

## Creating an Effect from a Promise

If you're dealing with asynchronous side effects that return a `Promise`, you can use the `promise` constructor:

```ts
import * as Effect from "@effect/io/Effect"

const fetchFirstTodo = Effect.promise(() =>
  fetch("https://jsonplaceholder.typicode.com/todos/1")
)
```

## Creating an Effect from a callback

Sometimes you have to work with APIs that don't support `async/await` or `Promise` and instead use the callback style.

To handle callback-based APIs, Effect provides the `async` constructor.

For example, let's wrap the `readFile` function from the Node.js `fs` module with Effect:

```ts
import * as Effect from "@effect/io/Effect"
import * as NodeFS from "node:fs"

const readTodos = Effect.async<never, NodeJS.ErrnoException, Buffer>(
  (resume) => {
    NodeFS.readFile("todos.txt", (error, data) => {
      if (error) {
        resume(Effect.fail(error))
      } else {
        resume(Effect.succeed(data))
      }
    })
  }
)
```

In the above example, we manually annotate the types when calling `Effect.async` because TypeScript cannot infer the type parameters for a callback
based on the return value inside the callback body. Annotating the types ensures that the values provided to `resume` match the expected types.

You can seamlessly mix synchronous and asynchronous code within the Effect framework. **Everything becomes an Effect**, enabling you to handle different types of effects in a unified way.

## Cheatsheet

| Name      | Given              | To                        |
| --------- | ------------------ | ------------------------- |
| `succeed` | `A`                | `Effect<never, never, A>` |
| `sync`    | `() => A`          | `Effect<never, never, A>` |
| `promise` | `() => Promise<A>` | `Effect<never, never, A>` |
| `async`   | `(E, A) => void`   | `Effect<never, E, A>`     |

## What to read next

Now that we know how to create effects, it's time to learn how to run them. Check out the next tutorial on [Running Effects](running-effects) to find out more.
