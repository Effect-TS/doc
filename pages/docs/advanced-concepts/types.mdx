# Effect's Types

The functional abstractions in `@effect/data` can be broadly divided into two categories.

- Abstractions For Concrete Types - These abstractions define properties of concrete types, such as `number` and `string`, as well as ways of combining those values.
- Abstractions For Parameterized Types - These abstractions define properties of parameterized types such as `ReadonlyArray` and `Option` and ways of combining them.

## Standard TypeScript Types

### Strings

| Module      | Name        | Given | To                            |
| ----------- | ----------- | ----- | ----------------------------- |
| Equivalence | string      |       | `Equivalence<string>`         |
| Order       | string      |       | `Order<string>`               |
| Semigroup   | string      |       | `Semigroup<string>`           |
| Monoid      | string      |       | `Monoid<string>`              |
| Predicate   | isString    |       | `Refinement<unknown, string>` |
| String      | Equivalence |       | `Equivalence<string>`         |
| String      | Order       |       | `Order<string>`               |
| String      | Semigroup   |       | `Semigroup<string>`           |
| String      | Monoid      |       | `Monoid<string>`              |
| String      | isString    |       | `Refinement<unknown, string>` |

### Numbers

| Module      | Name              | Given | To                            |
| ----------- | ----------------- | ----- | ----------------------------- |
| Equivalence | number            |       | `Equivalence<number>`         |
| Order       | number            |       | `Order<number>`               |
| Bounded     | number            |       | `Bounded<number>`             |
| Semigroup   | numberSum         |       | `Semigroup<number>`           |
| Semigroup   | numberMultiply    |       | `Semigroup<number>`           |
| Monoid      | numberSum         |       | `Monoid<number>`              |
| Monoid      | numberMultiply    |       | `Monoid<number>`              |
| Predicate   | isNumber          |       | `Refinement<unknown, number>` |
| Number      | Equivalence       |       | `Equivalence<number>`         |
| Number      | Order             |       | `Order<number>`               |
| Number      | SemigroupSum      |       | `Semigroup<number>`           |
| Number      | SemigroupMultiply |       | `Semigroup<number>`           |
| Number      | SemigroupMax      |       | `Semigroup<number>`           |
| Number      | SemigroupMin      |       | `Semigroup<number>`           |
| Number      | MonoidSum         |       | `Monoid<number>`              |
| Number      | MonoidMultiply    |       | `Monoid<number>`              |
| Number      | MonoidMax         |       | `Monoid<number>`              |
| Number      | MonoidMin         |       | `Monoid<number>`              |
| Number      | isNumber          |       | `Refinement<unknown, number>` |

### Booleans

| Module      | Name        | Given | To                             |
| ----------- | ----------- | ----- | ------------------------------ |
| Equivalence | boolean     |       | `Equivalence<boolean>`         |
| Order       | boolean     |       | `Order<boolean>`               |
| Semigroup   | booleanAny  |       | `Semigroup<boolean>`           |
| Semigroup   | booleanAll  |       | `Semigroup<boolean>`           |
| Monoid      | booleanAny  |       | `Monoid<boolean>`              |
| Monoid      | booleanAll  |       | `Monoid<boolean>`              |
| Predicate   | isBoolean   |       | `Refinement<unknown, boolean>` |
| Boolean     | Equivalence |       | `Equivalence<boolean>`         |
| Boolean     | Order       |       | `Order<boolean>`               |
| Boolean     | booleanAny  |       | `Semigroup<boolean>`           |
| Boolean     | booleanAll  |       | `Semigroup<boolean>`           |
| Boolean     | booleanAny  |       | `Monoid<boolean>`              |
| Boolean     | booleanAll  |       | `Monoid<boolean>`              |
| Boolean     | isBoolean   |       | `Refinement<unknown, boolean>` |

### Bigints

| Module      | Name              | Given | To                            |
| ----------- | ----------------- | ----- | ----------------------------- |
| Equivalence | bigint            |       | `Equivalence<bigint>`         |
| Order       | bigint            |       | `Order<bigint>`               |
| Semigroup   | bigintSum         |       | `Semigroup<bigint>`           |
| Semigroup   | bigintMultiply    |       | `Semigroup<bigint>`           |
| Monoid      | bigintSum         |       | `Monoid<bigint>`              |
| Monoid      | bigintMultiply    |       | `Monoid<bigint>`              |
| Predicate   | isBigint          |       | `Refinement<unknown, bigint>` |
| Bigint      | Equivalence       |       | `Equivalence<bigint>`         |
| Bigint      | Order             |       | `Order<bigint>`               |
| Bigint      | SemigroupSum      |       | `Semigroup<bigint>`           |
| Bigint      | SemigroupMultiply |       | `Semigroup<bigint>`           |
| Bigint      | MonoidSum         |       | `Monoid<bigint>`              |
| Bigint      | MonoidMultiply    |       | `Monoid<bigint>`              |
| Bigint      | isBigint          |       | `Refinement<unknown, bigint>` |

### Symbols

| Module      | Name     | Given | To                            |
| ----------- | -------- | ----- | ----------------------------- |
| Equivalence | symbol   |       | `Equivalence<symbol>`         |
| Predicate   | isSymbol |       | `Refinement<unknown, symbol>` |
| Symbol      | isSymbol |       | `Refinement<unknown, symbol>` |

### Tuples

This section covers the various modules and combinators that work with tuples.

| Module      | Name            | Given                                   | To                                     |
| ----------- | --------------- | --------------------------------------- | -------------------------------------- |
| Equivalence | tuple           | `[Equivalence<A>, Equivalence<B>, ...]` | `Equivalence<readonly [A, B, ...]>`    |
| Order       | tuple           | `[Order<A>, Order<B>, ...]`             | `Order<readonly [A, B, ...]>`          |
| Semigroup   | tuple           | `[Semigroup<A>, Semigroup<B>, ...]`     | `Semigroup<[A, B, ...]>`               |
| Monoid      | tuple           | `[Monoid<A>, Monoid<B>, ...]`           | `Monoid<[A, B, ...]>`                  |
| SemiProduct | nonEmptyTuple   | `[F<A>, F<B>, ...]` (cannot be empty)   | `F<[A, B, ...]>`                       |
| Product     | tuple           | `[F<A>, F<B>, ...]`                     | `F<[A, B, ...]>`                       |
| Either      | tuple           | `[Either<E1, A>, Either<E2, B>, ...]`   | `Either<E1 \| E2 \| ..., [A, B, ...]>` |
| Option      | tuple           | `[Option<A>, Option<B>, ...]`           | `Option<[A, B, ...]>`                  |
| Predicate   | tuple           | `[Predicate<A>, Predicate<B>, ...]`     | `Predicate<readonly [A, B, ...]>`      |
| These       | tuple           | `[These<E1, A>, These<E2, B>, ...]`     | `These<E1 \| E2 \| ..., [A, B, ...]>`  |
| Tuple       | getEquivalence  | `[Equivalence<A>, Equivalence<B>, ...]` | `Equivalence<readonly [A, B, ...]>`    |
| Tuple       | getOrder        | `[Order<A>, Order<B>, ...]`             | `Order<readonly [A, B, ...]>`          |
| Tuple       | getSemigroup    | `[Semigroup<A>, Semigroup<B>, ...]`     | `Semigroup<[A, B, ...]>`               |
| Tuple       | getMonoid       | `[Monoid<A>, Monoid<B>, ...]`           | `Monoid<[A, B, ...]>`                  |
| Tuple       | nonEmptyProduct | `[F<A>, F<B>, ...]` (cannot be empty)   | `F<[A, B, ...]>`                       |
| Tuple       | product         | `[F<A>, F<B>, ...]`                     | `F<[A, B, ...]>`                       |

### Arrays

This section covers the various modules and combinators that work with arrays.

| Module        | Name          | Given            | To                              |
| ------------- | ------------- | ---------------- | ------------------------------- |
| Equivalence   | array         | `Equivalence<A>` | `Equivalence<ReadonlyArray<A>>` |
| Order         | array         | `Order<A>`       | `Order<ReadonlyArray<A>>`       |
| Semigroup     | array         | `A`              | `Semigroup<Array<A>>`           |
| Semigroup     | readonlyArray | `A`              | `Semigroup<ReadonlyArray<A>>`   |
| Monoid        | array         | `A`              | `Monoid<Array<A>>`              |
| Monoid        | readonlyArray | `A`              | `Monoid<ReadonlyArray<A>>`      |
| ReadonlyArray | getSemigroup  | `A`              | `Semigroup<ReadonlyArray<A>>`   |
| ReadonlyArray | getMonoid     | `A`              | `Monoid<ReadonlyArray<A>>`      |

### Structs

This section covers the various modules and combinators that work with structs.

| Module      | Name            | Given                                           | To                                        |
| ----------- | --------------- | ----------------------------------------------- | ----------------------------------------- |
| Equivalence | struct          | `{ a: Equivalence<A>, b: Equivalence<B>, ... }` | `Equivalence<{ a: A, b: B, ... }>`        |
| Order       | struct          | `{ a: Order<A>, b: Order<B>, ... }`             | `Order<{ a: A, b: B, ... }>`              |
| Semigroup   | struct          | `{ a: Semigroup<A>, b: Semigroup<B>, ... }`     | `Semigroup<{ a: A, b: B, ... }>`          |
| Monoid      | struct          | `{ a: Monoid<A>, b: Monoid<B>, ... }`           | `Monoid<{ a: A, b: B, ... }>`             |
| SemiProduct | nonEmptyStruct  | `{ a: F<A>, b: F<B>, ... }` (cannot be empty)   | `F<{ a: A, b: B, ... }>`                  |
| Product     | struct          | `{ a: F<A>, b: F<B>, ... }`                     | `F<{ a: A, b: B, ... }>`                  |
| Either      | struct          | `{ a: Either<E1, A>, b: Either<E2, B>, ... }`   | `Either<E1 \| E2 \| ..., { a: A, b: B }>` |
| Option      | struct          | `{ a: Option<A>, b: Option<B>, ... }`           | `Option<{ a: A, b: B }>`                  |
| Predicate   | struct          | `{ a: Predicate<A>, b: Predicate<B>, ... }`     | `Predicate<Readonly<{ a: A, b: B }>>`     |
| These       | struct          | `{ a: These<E1, A>, b: These<E2, B>, ... }`     | `These<E1 \| E2 \| ..., { a: A, b: B }>`  |
| Struct      | getEquivalence  | `{ a: Equivalence<A>, b: Equivalence<B>, ... }` | `Equivalence<{ a: A, b: B, ... }>`        |
| Struct      | getOrder        | `{ a: Order<A>, b: Order<B>, ... }`             | `Order<{ a: A, b: B, ... }>`              |
| Struct      | getSemigroup    | `{ a: Semigroup<A>, b: Semigroup<B>, ... }`     | `Semigroup<{ a: A, b: B, ... }>`          |
| Struct      | getMonoid       | `{ a: Monoid<A>, b: Monoid<B>, ... }`           | `Monoid<{ a: A, b: B, ... }>`             |
| Struct      | nonEmptyProduct | `{ a: F<A>, b: F<B>, ... }` (cannot be empty)   | `F<{ a: A, b: B, ... }>`                  |
| Struct      | product         | `{ a: F<A>, b: F<B>, ... }`                     | `F<{ a: A, b: B, ... }>`                  |

### Records

This section covers the various modules and combinators that work with records.

| Module         | Name          | Given                                        | To                               |
| -------------- | ------------- | -------------------------------------------- | -------------------------------- |
| Equivalence    | record        | `Equivalence<A>`                             | `Equivalence<ReadonlyRecord<A>>` |
| ReadonlyRecord | get           | `key: string`, `ReadonlyRecord<A>`           | `Option<A>`                      |
| ReadonlyRecord | replaceOption | `key: string`, `B`, `ReadonlyRecord<A>`      | `Option<Record<string, A \| B>>` |
| ReadonlyRecord | modifyOption  | `key: string`, `A => B`, `ReadonlyRecord<A>` | `Option<Record<string, A \| B>>` |

## Concrete Types

Note: members are in bold.

### Bounded

A type class used to name the lower limit and the upper limit of a type.

Extends:

- `Order`

| Name         | Given        | To           |
| ------------ | ------------ | ------------ |
| **maxBound** |              | `A`          |
| **minBound** |              | `A`          |
| reverse      | `Bounded<A>` | `Bounded<A>` |
| clamp        | `A`          | `A`          |

### Equivalence

`Equivalence` defines a binary relation that is reflexive, symmetric, and transitive.
In other words, it defines a notion of equivalence between values of a certain type.
These properties are also known in mathematics as an "equivalence relation".

| Name         | Given                                           | To                                         |
| ------------ | ----------------------------------------------- | ------------------------------------------ |
| strict       | `A`                                             | `Equivalence<A>`                           |
| tuple        | `[Equivalence<A>, Equivalence<B>, ...]`         | `Equivalence<[A, B, ...]>`                 |
| array        | `Equivalence<A>`                                | `Equivalence<A[]>`                         |
| struct       | `{ a: Equivalence<A>, b: Equivalence<B>, ... }` | `Equivalence<{ a: A, b: B, ... }>`         |
| record       | `Equivalence<A>`                                | `Equivalence<{ readonly [x: string]: A }>` |
| getSemigroup | `A`                                             | `Semigroup<Equivalence<A>>`                |
| getMonoid    | `A`                                             | `Monoid<Equivalence<A>>`                   |
| contramap    | `Equivalence<A>`, `B => A`                      | `Equivalence<B>`                           |

### Monoid

A `Monoid` is a `Semigroup` with an identity. A `Monoid` is a specialization of a
`Semigroup`, so its operation must be associative. Additionally,
`x |> combine(empty) == empty |> combine(x) == x`. For example, if we have `Monoid<String>`,
with `combine` as string concatenation, then `empty = ""`.

Extends:

- `Semigroup`

| Name           | Given                                 | To                            |
| -------------- | ------------------------------------- | ----------------------------- |
| **empty**      |                                       | `A`                           |
| **combineAll** | `Iterable<A>`                         | `A`                           |
| reverse        | `Monoid<A>`                           | `Monoid<A>`                   |
| tuple          | `[Monoid<A>, Monoid<B>, ...]`         | `Monoid<[A, B, ...]>`         |
| struct         | `{ a: Monoid<A>, b: Monoid<B>, ... }` | `Monoid<{ a: A, b: B, ... }>` |
| min            | `Bounded<A>`                          | `Monoid<A>`                   |
| max            | `Bounded<A>`                          | `Monoid<A>`                   |

### Order

The `Order` type class is used to define a total ordering on some type `A`.
An order is defined by a relation `<=`, which obeys the following laws:

- either `x <= y` or `y <= x` (totality)
- if `x <= y` and `y <= x`, then `x == y` (antisymmetry)
- if `x <= y` and `y <= z`, then `x <= z` (transitivity)

The truth table for compare is defined as follows:

| `x <= y` | `x >= y` | Ordering |                       |
| -------- | -------- | -------- | --------------------- |
| `true`   | `true`   | `0`      | corresponds to x == y |
| `true`   | `false`  | `< 0`    | corresponds to x < y  |
| `false`  | `true`   | `> 0`    | corresponds to x > y  |

By the totality law, `x <= y` and `y <= x` cannot be both `false`.

| Name                 | Given                       | To                    |
| -------------------- | --------------------------- | --------------------- |
| **compare**          | `A`, `A`                    | `Ordering`            |
| reverse              | `Order<A>`                  | `Order<A>`            |
| contramap            | `Order<A>`, `B => A`        | `Order<B>`            |
| getSemigroup         |                             | `Semigroup<Order<A>>` |
| getMonoid            |                             | `Monoid<Order<A>>`    |
| tuple                | `[Order<A>, Order<B>, ...]` | `Order<[A, B, ...]>`  |
| lessThan             | `A`, `A`                    | `boolean`             |
| greaterThan          | `A`, `A`                    | `boolean`             |
| lessThanOrEqualTo    | `A`, `A`                    | `boolean`             |
| greaterThanOrEqualTo | `A`, `A`                    | `boolean`             |
| min                  | `A`, `A`                    | `boolean`             |
| max                  | `A`, `A`                    | `boolean`             |
| clamp                | `A`, `A`                    | `A`                   |
| between              | `A`                         | `boolean`             |

### Semigroup

A `Semigroup` is any set `A` with an associative operation (`combine`):

`x |> combine(y) |> combine(z) == x |> combine(y |> combine(z))`

| Name            | Given                                       | To                               |
| --------------- | ------------------------------------------- | -------------------------------- |
| **combine**     | `A`, `A`                                    | `A`                              |
| **combineMany** | `A`, `Iterable<A>`                          | `A`                              |
| reverse         | `Semigroup<A>`                              | `Semigroup<A>`                   |
| tuple           | `[Semigroup<A>, Semigroup<B>, ...]`         | `Semigroup<[A, B, ...]>`         |
| struct          | `{ a: Semigroup<A>, b: Semigroup<B>, ... }` | `Semigroup<{ a: A, b: B, ... }>` |
| min             | `Order<A>`                                  | `Semigroup<A>`                   |
| max             | `Order<A>`                                  | `Semigroup<A>`                   |
| constant        | `A`                                         | `Semigroup<A>`                   |
| intercalate     | `A`, `Semigroup<A>`                         | `Semigroup<A>`                   |
| first           |                                             | `Semigroup<A>`                   |
| last            |                                             | `Semigroup<A>`                   |

## Parameterized Types

**Parameterized Types Hierarchy**

<br />
```mermaid flowchart TD Alternative --> SemiAlternative Alternative --> Coproduct
Applicative --> Product Coproduct --> SemiCoproduct SemiAlternative --> Covariant
SemiAlternative --> SemiCoproduct SemiApplicative --> SemiProduct SemiApplicative
--> Covariant Applicative --> SemiApplicative Chainable --> FlatMap Chainable --->
Covariant Monad --> FlatMap Monad --> Pointed Pointed --> Of Pointed --> Covariant
Product --> SemiProduct Product --> Of SemiProduct --> Invariant Covariant --> Invariant
SemiCoproduct --> Invariant ```

Note: members are in bold.

### Alternative

Extends:

- `SemiAlternative`
- `Coproduct`

### Applicative

Extends:

- `SemiApplicative`
- `Product`

| Name       | Given       | To             |
| ---------- | ----------- | -------------- |
| liftMonoid | `Monoid<A>` | `Monoid<F<A>>` |

### Bicovariant

A type class of types which give rise to two independent, covariant
functors.

| Name      | Given                            | To         |
| --------- | -------------------------------- | ---------- |
| **bimap** | `F<E1, A>`, `E1 => E2`, `A => B` | `F<E2, B>` |
| mapLeft   | `F<E1, A>`, `E1 => E2`           | `F<E2, A>` |
| map       | `F<A>`, `A => B`                 | `F<B>`     |

### Chainable

Extends:

- `FlatMap`
- `Covariant`

| Name           | Given                               | To                     |
| -------------- | ----------------------------------- | ---------------------- |
| tap            | `F<A>`, `A => F<B>`                 | `F<A>`                 |
| andThenDiscard | `F<A>`, `F<B>`                      | `F<A>`                 |
| bind           | `F<A>`, `name: string`, `A => F<B>` | `F<A & { [name]: B }>` |

### Contravariant

Contravariant functors.

Extends:

- `Invariant`

| Name                 | Given               | To        |
| -------------------- | ------------------- | --------- |
| **contramap**        | `F<A>`, `B => A`    | `F<B>`    |
| contramapComposition | `F<G<A>>`, `A => B` | `F<G<B>>` |
| imap                 | `contramap`         | `imap`    |

### Coproduct

`Coproduct` is a universal monoid which operates on kinds.

This type class is useful when its type parameter `F<_>` has a
structure that can be combined for any particular type, and which
also has a "zero" representation. Thus, `Coproduct` is like a `Monoid`
for kinds (i.e. parametrized types).

A `Coproduct<F>` can produce a `Monoid<F<A>>` for any type `A`.

Here's how to distinguish `Monoid` and `Coproduct`:

- `Monoid<A>` allows `A` values to be combined, and also means there
  is an "empty" `A` value that functions as an identity.

- `Coproduct<F>` allows two `F<A>` values to be combined, for any `A`. It
  also means that for any `A`, there is an "zero" `F<A>` value. The
  combination operation and zero value just depend on the
  structure of `F`, but not on the structure of `A`.

Extends:

- `SemiCoproduct`

| Name             | Given            | To             |
| ---------------- | ---------------- | -------------- |
| **zero**         |                  | `F<A>`         |
| **coproductAll** | `Iterable<F<A>>` | `F<A>`         |
| getMonoid        |                  | `Monoid<F<A>>` |

### Covariant

Covariant functors.

Extends:

- `Invariant`

| Name           | Given               | To        |
| -------------- | ------------------- | --------- |
| **map**        | `F<A>`, `A => B`    | `F<B>`    |
| mapComposition | `F<G<A>>`, `A => B` | `F<G<B>>` |
| imap           | `map`               | `imap`    |
| flap           | `A`, `F<A => B>`    | `F<B>`    |
| as             | `F<A>`, `B`         | `F<B>`    |
| asUnit         | `F<A>`              | `F<void>` |

### Filterable

`Filterable<F>` allows you to `map` and filter out elements simultaneously.

| Name                    | Given                          | To                   |
| ----------------------- | ------------------------------ | -------------------- |
| **partitionMap**        | `F<A>`, `A => Either<B, C>`    | `[F<B>, F<C>]`       |
| **filterMap**           | `F<A>`, `A => Option<B>`       | `F<B>`               |
| compact                 | `F<Option<A>>`                 | `F<A>`               |
| separate                | `F<Either<A, B>>`              | `[F<A>, F<B>]`       |
| filter                  | `F<A>`, `A => boolean`         | `F<A>`               |
| partition               | `F<A>`, `A => boolean`         | `[F<A>, F<A>]`       |
| partitionMapComposition | `F<G<A>>`, `A => Either<B, C>` | `[F<G<B>>, F<G<C>>]` |
| filterMapComposition    | `F<G<A>>`, `A => Option<B>`    | `F<G<B>>`            |

### FlatMap

| Name                | Given                    | To          |
| ------------------- | ------------------------ | ----------- |
| **flatMap**         | `F<A>`, `A => F<B>`      | `F<B>`      |
| flatten             | `F<F<A>>`                | `F<A>`      |
| andThen             | `F<A>`, `F<B>`           | `F<B>`      |
| composeKleisliArrow | `A => F<B>`, `B => F<C>` | `A => F<C>` |

### Foldable

Data structures that can be folded to a summary value.

In the case of a collection (such as `ReadonlyArray`), these
methods will fold together (combine) the values contained in the
collection to produce a single result. Most collection types have
`reduce` methods, which will usually be used by the associated
`Foldable<F>` instance.

| Name                | Given                                     | To                 |
| ------------------- | ----------------------------------------- | ------------------ |
| **reduce**          | `F<A>`, `B`, `(B, A) => B`                | `B`                |
| reduceComposition   | `F<G<A>>`, `B`, `(B, A) => B`             | `B`                |
| reduceRight         | `F<A>`, `B`, `(B, A) => B`                | `B`                |
| foldMap             | `F<A>`, `Monoid<M>`, `A => M`             | `M`                |
| toReadonlyArray     | `F<A>`                                    | `ReadonlyArray<A>` |
| toReadonlyArrayWith | `F<A>`, `A => B`                          | `ReadonlyArray<B>` |
| reduceKind          | `Monad<G>`, `F<A>`, `B`, `(B, A) => G<B>` | `G<B>`             |
| reduceRightKind     | `Monad<G>`, `F<A>`, `B`, `(B, A) => G<B>` | `G<B>`             |
| foldMapKind         | `Coproduct<G>`, `F<A>`, `(A) => G<B>`     | `G<B>`             |

### Invariant

Invariant functors.

| Name            | Given                         | To                 |
| --------------- | ----------------------------- | ------------------ |
| **imap**        | `F<A>`, `A => B`, `B => A`    | `F<B>`             |
| imapComposition | `F<G<A>>`, `A => B`, `B => A` | `F<G<B>>`          |
| bindTo          | `F<A>`, `name: string`        | `F<{ [name]: A }>` |
| tupled          | `F<A>`                        | `F<[A]>`           |

### Monad

Allows composition of dependent effectful functions.

Extends:

- `FlatMap`
- `Pointed`

### Of

| Name          | Given | To        |
| ------------- | ----- | --------- |
| **of**        | `A`   | `F<A>`    |
| ofComposition | `A`   | `F<G<A>>` |
| unit          |       | `F<void>` |
| Do            |       | `F<{}>`   |

### Pointed

Extends:

- `Covariant`
- `Of`

### Product

Extends:

- `SemiProduct`
- `Of`

| Name           | Given                       | To                       |
| -------------- | --------------------------- | ------------------------ |
| **productAll** | `Iterable<F<A>>`            | `F<ReadonlyArray<A>>`    |
| tuple          | `[F<A>, F<B>, ...]`         | `F<[A, B, ...]>`         |
| struct         | `{ a: F<A>, b: F<B>, ... }` | `F<{ a: A, b: B, ... }>` |

### SemiAlternative

Extends:

- `SemiCoproduct`
- `Covariant`

### SemiApplicative

Extends:

- `SemiProduct`
- `Covariant`

| Name           | Given               | To                           |
| -------------- | ------------------- | ---------------------------- |
| liftSemigroup  | `Semigroup<A>`      | `Semigroup<F<A>>`            |
| ap             | `F<A => B>`, `F<A>` | `F<B>`                       |
| andThenDiscard | `F<A>`, `F<B>`      | `F<A>`                       |
| andThen        | `F<A>`, `F<B>`      | `F<B>`                       |
| lift2          | `(A, B) => C`       | `(F<A>, F<B>) => F<C>`       |
| lift3          | `(A, B, C) => D`    | `(F<A>, F<B>, F<C>) => F<D>` |

### SemiCoproduct

`SemiCoproduct` is a universal semigroup which operates on kinds.

This type class is useful when its type parameter `F<_>` has a
structure that can be combined for any particular type. Thus,
`SemiCoproduct` is like a `Semigroup` for kinds (i.e. parametrized
types).

A `SemiCoproduct<F>` can produce a `Semigroup<F<A>>` for any type A.

Here's how to distinguish `Semigroup` and `SemiCoproduct`:

- `Semigroup<A>` allows two `A` values to be combined.

- `SemiCoproduct<F>` allows two `F<A>` values to be combined, for any `A`.
  The combination operation just depends on the structure of `F`,
  but not the structure of `A`.

Extends:

- `Invariant`

| Name              | Given            | To                |
| ----------------- | ---------------- | ----------------- |
| **coproduct**     | `F<A>`, `F<B>`   | `F<A \| B>`       |
| **coproductMany** | `Iterable<F<A>>` | `F<A>`            |
| getSemigroup      |                  | `Semigroup<F<A>>` |
| coproductEither   | `F<A>`, `F<B>`   | `F<Either<A, B>>` |

### SemiProduct

Extends:

- `Invariant`

| Name                   | Given                          | To                               |
| ---------------------- | ------------------------------ | -------------------------------- |
| **product**            | `F<A>`, `F<B>`                 | `F<[A, B]>`                      |
| **productMany**        | `F<A>`, `Iterable<F<A>>`       | `F<[A, ...ReadonlyArray<A>]>`    |
| productComposition     | `F<G<A>>`, `F<G<B>>`           | `F<G<[A, B]>>`                   |
| productManyComposition | `F<G<A>>`, `Iterable<F<G<A>>>` | `F<G<[A, ...ReadonlyArray<A>]>>` |
| nonEmptyTuple          | `[F<A>, F<B>, ...]`            | `F<[A, B, ...]>`                 |
| nonEmptyStruct         | `{ a: F<A>, b: F<B>, ... }`    | `F<{ a: A, b: B, ... }>`         |
| andThenBind            | `F<A>`, `name: string`, `F<B>` | `F<A & { [name]: B }>`           |
| productFlatten         | `F<A>`, `F<B>`                 | `F<[...A, B]>`                   |

### Traversable

Traversal over a structure with an effect.

| Name                | Given                                    | To           |
| ------------------- | ---------------------------------------- | ------------ |
| **traverse**        | `Applicative<F>`, `T<A>`, `A => F<B>`    | `F<T<B>>`    |
| traverseComposition | `Applicative<F>`, `T<G<A>>`, `A => F<B>` | `F<T<G<B>>>` |
| sequence            | `Applicative<F>`, `T<F<A>>`              | `F<T<A>>`    |
| traverseTap         | `Applicative<F>`, `T<A>`, `A => F<B>`    | `F<T<A>>`    |

### TraversableFilterable

`TraversableFilterable`, also known as `Witherable`, represents list-like structures
that can essentially have a `traverse` and a `filter` applied as a single
combined operation (`traverseFilter`).

| Name                     | Given                                            | To                |
| ------------------------ | ------------------------------------------------ | ----------------- |
| **traversePartitionMap** | `Applicative<F>`, `T<A>`, `A => F<Either<B, C>>` | `F<[T<B>, T<C>]>` |
| **traverseFilterMap**    | `Applicative<F>`, `T<A>`, `A => F<Option<B>>`    | `F<T<B>>`         |
| traverseFilter           | `Applicative<F>`, `T<A>`, `A => F<boolean>`      | `F<T<A>>`         |
| traversePartition        | `Applicative<F>`, `T<A>`, `A => F<boolean>`      | `F<[T<A>, T<A>]>` |

---

Adapted from:

- [cats](https://github.com/typelevel/cats)
- [zio-prelude](https://github.com/zio/zio-prelude)
- [zio-cheatsheet](https://github.com/ghostdogpr/zio-cheatsheet)
