# Introduction to Metrics in Effect

In complex and highly concurrent applications, managing various interconnected components can be quite challenging. Ensuring that everything runs smoothly and avoiding application downtime becomes crucial in such setups.

Now, let's imagine we have a sophisticated infrastructure with numerous services. These services are replicated and distributed across our servers. However, we often lack insight into what's happening across these services, including error rates, response times, and service uptime. This lack of visibility can make it challenging to identify and address issues effectively. This is where Effect Metrics comes into play; it allows us to capture and analyze various metrics, providing valuable data for later investigation.

Effect Metrics offers support for five different types of metrics:

1. **Counter**: Counters are used to track values that increase over time, such as request counts. They help us keep tabs on how many times a specific event or action has occurred.

2. **Gauge**: Gauges represent a single numerical value that can fluctuate up and down over time. They are often used to monitor metrics like memory usage, which can vary continuously.

3. **Histogram**: Histograms are useful for tracking the distribution of observed values across different buckets. They are commonly used for metrics like request latencies, allowing us to understand how response times are distributed.

4. **Summary**: Summaries provide insight into a sliding window of a time series and offer metrics for specific percentiles of the time series, often referred to as quantiles. This is particularly helpful for understanding latency-related metrics, such as request response times.

5. **Frequency**: Frequency metrics count the occurrences of distinct string values. They are useful when you want to keep track of how often different events or conditions are happening in your application.

## Counter

In the world of metrics, a Counter is a metric that represents a single numerical value that can be incremented over time. Think of it like a tally that keeps track of something increasing, such as the number of a particular type of request received by your application.

Unlike some other types of metrics (like gauges), where we're interested in the value at a specific moment, with counters, we care about the cumulative value over time.

### How to Create a Counter

To create a counter, you can use the `Metric.counter` constructor in your code. You have the option to specify the type of the counter as either `number` or `bigint`. Here's how you can do it:

```ts file=<rootDir>/src/guide/observability/otel/metrics/counter/constructor.ts

```

### When to Use Counters

Counters are incredibly useful when you want to keep track of values that only go up. They are not suitable for values that can decrease over time. So, when should you use counters?

1. **Tracking a Value Over Time**: If you need to monitor something that consistently increases over time, like the number of incoming requests, counters are your go-to choice.

2. **Measuring Growth Rates**: Counters are also handy when you want to measure how fast something is growing. For instance, you can use them to keep tabs on request rates.

### Common Use Cases

Counters find application in various scenarios, including:

- **Request Counts**: Monitoring the number of incoming requests to your server.

- **Completed Tasks**: Keeping track of how many tasks or processes have been successfully completed.

- **Error Counts**: Counting the occurrences of errors in your application.

### Example

Here's a practical example of creating and using a counter in your code:

```ts file=<rootDir>/src/guide/observability/otel/metrics/counter/example.ts

```

In this example, we create a counter called `countAll`, which is incremented by 1 each time it's invoked. We then use it to monitor the number of times certain tasks are executed. The result provides valuable insights into the cumulative count of these tasks.

It's worth noting that applying the `countAll` metric to an effect doesn't change its type. So, if `task1` has a type of `Effect<never, never, number>`, then `countAll(task1)` still has the same type, `Effect<never, never, number>`.

## Gauge

In the world of metrics, a Gauge is a metric that represents a single numerical value that can be set or adjusted. Think of it as a dynamic variable that can change over time. One common use case for a gauge is to monitor something like the current memory usage of your application.

Unlike counters, where we're interested in cumulative values over time, with gauges, our focus is on the current value at a specific point in time.

### How to Create a Gauge

To create a gauge, you can use the `Metric.gauge` constructor in your code. You can specify the type of the gauge as either `number` or `bigint`. Here's how you can do it:

```ts file=<rootDir>/src/guide/observability/otel/metrics/gauge/constructor.ts

```

### When to Use Gauges

Gauges are the best choice when you want to monitor values that can both increase and decrease, and you're not interested in tracking their rates of change. In other words, gauges help us measure things that have a specific value at a particular moment:

- **Memory Usage**: Keeping an eye on how much memory your application is using right now.

- **Queue Size**: Monitoring the current size of a queue where tasks are waiting to be processed.

- **In-Progress Request Counts**: Tracking the number of requests currently being handled by your server.

- **Temperature**: Measuring the current temperature, which can fluctuate up and down.

### Example

Let's look at a practical example of creating and using a gauge in your code:

```ts file=<rootDir>/src/guide/observability/otel/metrics/gauge/example.ts

```

## Histogram

A Histogram is a metric that helps us understand how a collection of numerical values is distributed over time. Instead of just focusing on the individual values, histograms organize these values into distinct intervals, called buckets, and record the frequency of values within each bucket.

Histograms are valuable because they not only represent the actual values but also provide insights into their distribution. They are like a summary of a dataset, breaking down the data into buckets and showing how many data points fall into each one.

### How Histograms Work

In a histogram, each incoming sample is assigned to a predefined bucket. When a data point arrives, it increases the count for the corresponding bucket, and then the individual sample is discarded. This bucketed approach allows us to aggregate data across multiple instances. Histograms are especially useful for measuring percentiles, helping us estimate specific percentiles by looking at bucket counts.

### Key Concepts

- **Observing Values:** Histograms observe numerical values and count how many observations fall into specific buckets. Each bucket has an upper boundary, and the count for a bucket increases by 1 if an observed value is less than or equal to the bucket's upper boundary.

- **Overall Count:** A histogram also keeps track of the total count of observed values and the sum of all observed values.

- **Inspired by Prometheus:** The concept of histograms is inspired by [Prometheus](https://prometheus.io/docs/concepts/metric_types/#histogram), a popular monitoring and alerting toolkit.

### When to Use Histograms

Histograms are widely used in software metrics for various purposes, especially in analyzing the performance of software systems. They are valuable for metrics such as response times, latencies, and throughput. By visualizing the distribution of these metrics in a histogram, developers can identify performance bottlenecks, outliers, or variations. This information helps in optimizing code, infrastructure, and system configurations to improve overall performance.

Histograms are the best choice in the following situations:

- When you want to observe many values and later calculate percentiles of those observed values.

- When you can estimate the range of values in advance, as histograms organize observations into predefined buckets.

- When you don't require exact values due to the inherent lossy nature of bucketing data in histograms.

- When you need to aggregate histograms across multiple instances.

### Examples

#### Histogram With Linear Buckets

In this example, we create a histogram with linear buckets, ranging from 0 to 100 in increments of 10, and an "Infinity" bucket. It's suitable for effects yielding a `number`. The program then generates random values, records them in the histogram, and displays the histogram's state.

```ts file=<rootDir>/src/guide/observability/otel/metrics/histogram/linear.ts

```

#### Timer Metric

This example demonstrates the use of a timer metric to track workflow durations. It generates random values, simulates waiting times, records durations in the timer metric, and displays the histogram's state.

```ts file=<rootDir>/src/guide/observability/otel/metrics/histogram/timer.ts

```

These examples showcase how histograms can be used to analyze and understand the distribution of data in various scenarios, making them a valuable tool in software metrics.

## Summary

## Frequency
