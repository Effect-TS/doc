import { Design } from "@/components/Callout"

# Dual APIs

When working with APIs in the Effect ecosystem,
you'll come across two different way to use the same API, corrsponding to two TypeScript overloads:

- the "data-last" variant
- the "data-first" variant

Let's explore each variant and understand how they differ and how they are used.

Let's pick for example the `Effect.map` API, this is its type:

```ts
export declare const map: {
  // 1) "data-last" overload
  <A, B>(f: (a: A) => B): <R, E>(self: Effect<R, E, A>) => Effect<R, E, B>

  // 2) "data-first" overload
  <R, E, A, B>(self: Effect<R, E, A>, f: (a: A) => B): Effect<R, E, B>
}
```

As you can see `map` is defined as a function with two TypeScript overloads.

The "data-last" overload is the one we have been using so far with `pipe`. In this variant, the `Effect` is passed as the first argument to the `pipe` function, followed by the corresponding `Effect` function, such as `Effect.map`:

```ts
const mappedEffect = pipe(effect, Effect.map(func))
```

This overload is useful when you need to chain multiple computations in a long pipeline. You can continue the pipeline by adding more computations after the initial transformation:

```ts
pipe(effect, Effect.map(func1), Effect.flatMap(func2), ...)
```

On the other hand, the "data-first" overload doesn't require the `pipe` function. Instead, you directly pass the `Effect` as the first argument to the corresponding `Effect` function:

```ts
const mappedEffect = Effect.map(effect, func)
```

This overload is convenient when you only need to perform a single operation on the `Effect`.

When an API like `Effect.map` supports both overloads, we call them "dual" APIs.

Both variants have their advantages, and the choice depends on personal preference and the coding style of the project.

<Design>
  **Choosing Between the overloads**. It's important to note that both overloads
  achieve the same result. They are simply two different ways of expressing the
  code. You can choose the overload that best fits your coding style and makes
  the code more readable for you and your team.
</Design>
