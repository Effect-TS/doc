import { Info, Warning } from "@/components/Callout"

# How to write idiomatic code

The Effect style guide provides recommendations for writing Effect modules.

## Modules

The Effect ecosystem consists of multiple modules. To avoid name conflicts, it is recommended to use the

**`import * as ...`**

syntax when importing modules.
This approach helps create namespaces for the modules.

Examples:

```ts
import * as Effect from "@effect/io/Effect"
import * as Context from "@effect/data/Context"
import * as Duration from "@effect/data/Duration"
```

### Types and interfaces

Types and interfaces should also be "namespaced" to prevent clashes. While it may seem verbose, this explicit style ensures that code written in this manner will never have naming conflicts.

Examples:

```ts
import * as Effect from "@effect/io/Effect"

// ✅
const good: Effect.Effect<Random, Error, number> = ...

// ❌
const bad: Effect<Random, Error, number> = ...
```

There is only one exception to this rule. Functions from the `Function` module can be used directly without the namespace.

```ts
import { pipe } from "@effect/data/Function"
```

## Writing Code with Effect

Nested callbacks are a common challenge in JavaScript, often addressed using `async`/`await` syntax in modern JavaScript codebases. However, when working with Effects, the available APIs are slightly different.

This section will cover three common ways to organize Effectful code:

- Using `pipe`
- Using generators
- Using the `Do` simulation

### Using pipe

The basic syntax of `pipe` is as follows:

```ts
import { pipe } from "@effect/data/Function";

const result = pipe(input, func1, func2, ..., funcN);
```

Here, `input` is the initial value, and `func1`, `func2`, ..., `funcN` are the functions to be applied in sequence. The result of each function becomes the input for the next function, and the final result is returned.

Let's see an example to understand it better.

```ts
import { pipe } from "@effect/data/Function"
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"

const program = pipe(
  Random.next(),
  Effect.flatMap((n) =>
    n > 0.5 ? Effect.succeed("yay!") : Effect.fail("oh no!")
  )
)
```

In this example, `Random.next()` is piped as an argument to `Effect.flatMap`.

### Using generators

Effect provides a unique imperative API to address the issue of nested callbacks encountered when using functions like `pipe`. Instead of the previous code, let's see how it would look using the generator API:

```ts
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"

const program = Effect.gen(function* (_) {
  const n = yield* _(Random.next())
  if (n > 0.5) {
    return yield* _(Effect.succeed("yay!"))
  } else {
    return yield* _(Effect.fail("oh no!"))
  }
})
```

<Warning>
  The generator API is only available when using the `downlevelIteration` flag
  or with a `target` of `"es2015"` or higher in your `tsconfig.json` file
</Warning>

Notice the use of `yield*` to retrieve the next value from the generator:

```ts {2}
const program = Effect.gen(function* (_) {
  const n = yield* _(Random.next())
  /* ... */
})
```

When yielding an effect, it is necessary to pass the Effect you want to `yield*` to the helper function `_`, which is passed as an argument to `Effect.gen`. This ensures that TypeScript can correctly infer the types.

<Info>
  The `_` symbol is just a convention for the argument name and is not a special
  symbol in Effect. You are free to use any name you prefer (e.g., `$`, etc...).
  The current convention is to use `_` as the argument name.
</Info>

#### Using the helper as a `pipe`

The `_` helper can also be used as a `pipe` function.

In the following example, `Random.next()` is piped into `Effect.map`.

```ts
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"

const program = Effect.gen(function* (_) {
  const n = yield* _(
    Random.next(),
    Effect.map((n) => n * 2)
  )
  if (n > 0.5) {
    return yield* _(Effect.succeed("yay!"))
  } else {
    return yield* _(Effect.fail("oh no!"))
  }
})
```

### Using the `Do` simulation

The `Do` simulation in Effect allows you to write code in a more declarative style, resembling the "do notation" found in other programming languages.
It creates a scope where you can define variables and perform operations on them using functions like `Effect.bind`, `Effect.let`, and `Effect.flatMap`.

Here's how the `Do` simulation works:

1. Import the necessary modules:

```ts
import * as Effect from "@effect/io/Effect"
import { pipe } from "@effect/data/Function"
```

2. Use the `pipe` function to start the `Do` simulation:

```ts
const program = pipe(
  Effect.Do()
  // ... rest of the code
)
```

3. Inside the `Do` simulation scope, you can use the `Effect.bind` function to define variables and bind them to `Effect` values:

```ts
Effect.bind("variableName", () => effectValue)
```

- `variableName` is the name of the variable you want to define. You can choose any name you like.
- `effectValue` is the `Effect` value that you want to bind to the variable. It can be the result of a function call or any other valid `Effect` value.

4. You can accumulate multiple `Effect.bind` statements to define multiple variables within the scope:

```ts
Effect.bind("variable1", () => effectValue1),
Effect.bind("variable2", ({ variable1 }) => effectValue2),
// ... additional bind statements
```

5. Note that you can still use regular Effect functions like `Effect.flatMap` within the `Do` simulation. They will receive the accumulated variables as arguments within the scope.

```ts
Effect.flatMap(({ variable1, variable2 }) => {
  // Perform operations using variable1 and variable2
  // Return an `Effect` value as the result
})
```

Here's an example to illustrate the usage of the `Do` simulation:

```ts
const program = pipe(
  Effect.Do(),
  Effect.bind("n", () => Random.next()),
  Effect.flatMap(({ n }) =>
    n > 0.5 ? Effect.succeed("yay!") : Effect.fail("oh no!")
  )
)
```

In this example, the `"n"` variable is defined using `Effect.bind`, and then it is used within the `Effect.flatMap`
to determine the success or failure of the program based on the numeric value of `n`.
