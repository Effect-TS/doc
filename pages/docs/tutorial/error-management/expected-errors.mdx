import { Info, Idea, Warning } from "@/components/Callout"
import { Tabs, Tab } from "@/components/Code"

# Expected Errors

In this tutorial you will learn:

- How Effect represents expected errors
- The tools Effect provides for robust and comprehensive error management

As we saw in the tutorial [Creating Effects](../../essentials/creating), we can use the `fail` constructor to create an Effect
that represents an error:

```ts
import * as Effect from "@effect/io/Effect"

class HttpError {
  readonly _tag = "HttpError"
}

const program: Effect.Effect<never, HttpError, never> = Effect.fail(
  new HttpError()
)
```

<Info>
  We use a class to represent the `HttpError` type above simply to gain access
  to both the error type and a free constructor. However, you can use whatever
  you like to model your error types.
</Info>

It's worth noting that we added a `_tag` field to our error in the example.

```ts /_tag/
class HttpError {
  readonly _tag = "HttpError"
}
```

<Idea>
  A discriminant field can be helpful for distinguishing between different types
  of errors during error handling and prevents TypeScript from unifying types.
</Idea>

Expected errors **are tracked at the type level** by the `Effect` data type in the "Error" channel.

It is evident from the type of `program` that can fail with an error of type `HttpError`:

```ts /HttpError/
Effect.Effect<never, HttpError, never>
```

## Error Accumulation

The following program serves as an illustration of how errors are automatically tracked and accumulated for you:

<Tabs>
  <Tab>

```ts
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"

class FooError {
  readonly _tag = "FooError"
}

class BarError {
  readonly _tag = "BarError"
}

const flakyFoo = Random.next.pipe(
  Effect.flatMap((n1) =>
    n1 > 0.5 ? Effect.succeed("yay!") : Effect.fail(new FooError())
  )
)

const flakyBar = Random.next.pipe(
  Effect.flatMap((n2) =>
    n2 > 0.5 ? Effect.succeed("yay!") : Effect.fail(new BarError())
  )
)

// Effect<never, FooError | BarError, string>
const program = Effect.all([flakyFoo, flakyBar]).pipe(
  Effect.map(([foo, bar]) => foo + bar)
)
```

In the above program, we have two operations: `flakyFoo` and `flakyBar`, each representing a potential source of error.
These operations are combined using the `Effect.all(effects){:ts}` function from the Effect library, which allows us to sequence them together.

  </Tab>
  <Tab>

```ts
import * as Effect from "@effect/io/Effect"
import * as Random from "@effect/io/Random"

class FooError {
  readonly _tag = "FooError"
}

class BarError {
  readonly _tag = "BarError"
}

// Effect<never, FooError | BarError, string>
const program = Effect.gen(function* (_) {
  const n1 = yield* _(Random.next)
  const n2 = yield* _(Random.next)

  const foo =
    n1 > 0.5
      ? yield* _(Effect.succeed("yay!"))
      : yield* _(Effect.fail(new FooError()))

  const bar =
    n2 > 0.5
      ? yield* _(Effect.succeed("yay!"))
      : yield* _(Effect.fail(new BarError()))

  return foo + bar
})
```

  </Tab>
</Tabs>

Effect automatically keeps track of the possible errors that can occur during the execution of the program.
In this case, we have `FooError` and `BarError` as the possible error types.
The error channel of the `program` is specified as

```ts /FooError | BarError/
Effect<never, FooError | BarError, string>
```

indicating that it can potentially fail with either a `FooError` or a `BarError`.

## Catching

To handle errors in a simple way, you can use the `catchAll` function.

### catchAll

The `catchAll` function allows you to catch any error that occurs in the program and provide a fallback.

<Tabs>
<Tab>

```ts {3}
// Effect<never, never, string>
const recovered = program.pipe(
  Effect.catchAll((error) => Effect.succeed(`Recovering from ${error._tag}`))
)
```

</Tab>
<Tab>

```ts {6-9}
import * as Either from "@effect/data/Either"

// Effect<never, never, string>
const recovered = Effect.gen(function* (_) {
  const successOrFailure = yield* _(Effect.either(program))
  if (Either.isLeft(successOrFailure)) {
    const error = successOrFailure.left
    return `Recovering from ${error._tag}`
  }
  return successOrFailure.right
})
```

</Tab>
</Tabs>

We can observe that the type in the error channel of our `program` has changed to `never`,
indicating that all errors has been handled.

```ts /never/2
Effect<never, never, string>
```

### catchTag

Suppose we only want to handle `FooError`. In that case, we can use the `catchTag` method provided by Effect:

<Tabs>
<Tab>

```ts {3-5}
// Effect<never, BarError, string>
const recovered = program.pipe(
  Effect.catchTag("FooError", (fooError) =>
    Effect.succeed("Recovering from FooError")
  )
)
```

In the example above, the `catchTag` function allows us to handle `FooError` specifically.
If a `FooError` occurs during the execution of the program, the provided error handler function will be invoked,
and the program will proceed with the recovery logic specified within the handler.

</Tab>
<Tab>

```ts {8-10}
import * as Either from "@effect/data/Either"

// Effect<never, BarError, string>
const recovered = Effect.gen(function* (_) {
  const successOrFailure = yield* _(Effect.either(program))
  if (Either.isLeft(successOrFailure)) {
    const error = successOrFailure.left
    if (error._tag === "FooError") {
      return "Recovering from FooError"
    }
    return yield* _(Effect.fail(error))
  }
  return successOrFailure.right
})
```

</Tab>
</Tabs>

We can observe that the type in the error channel of our `program` has changed to only show `BarError`,
indicating that `FooError` has been handled.

```ts /BarError/
Effect<never, BarError, string>
```

If we also wanted to handle `BarError`, we can simply add another `catchTag`.

<Tabs>
<Tab>

```ts {6-8}
// Effect<never, never, string>
const recovered = program.pipe(
  Effect.catchTag("FooError", (_fooError) =>
    Effect.succeed("Recovering from FooError")
  ),
  Effect.catchTag("BarError", (_barError) =>
    Effect.succeed("Recovering from BarError")
  )
)
```

</Tab>
<Tab>

```ts {11}
import * as Either from "@effect/data/Either"

// Effect<never, never, string>
const recovered = Effect.gen(function* (_) {
  const successOrFailure = yield* _(Effect.either(program))
  if (Either.isLeft(successOrFailure)) {
    const error = successOrFailure.left
    if (error._tag === "FooError") {
      return "Recovering from FooError"
    }
    return "Recovering from BarError"
  }
  return successOrFailure.right
})
```

</Tab>
</Tabs>

<Warning>
  It is important to ensure that the error type used with `catchTag` has a
  `readonly _tag` discriminant field. This field is required for the matching
  and handling of specific error tags.
</Warning>

### catchTags

Instead of using the `catchTag` combinator multiple times to handle individual error types, we have a more convenient option called `catchTags`. With `catchTags`, we can handle multiple errors in a single block of code.

<Tabs>
<Tab>

```ts {3-6}
// Effect<never, never, string>
const recovered = program.pipe(
  Effect.catchTags({
    FooError: (_fooError) => Effect.succeed(`Recovering from FooError`),
    BarError: (_barError) => Effect.succeed(`Recovering from BarError`),
  })
)
```

In the above example, instead of using `catchTag` multiple times to handle individual errors, we utilize the `catchTags` combinator.
This combinator takes an object where each property represents a specific error `_tag` (`"FooError"` and `"BarError"` in this case),
and the corresponding value is the error handler function to be executed when that particular error occurs.

</Tab>
<Tab>

```ts {8-13}
import * as Either from "@effect/data/Either"

// Effect<never, never, string>
const recovered = Effect.gen(function* (_) {
  const successOrFailure = yield* _(Effect.either(program))
  if (Either.isLeft(successOrFailure)) {
    const error = successOrFailure.left
    switch (error._tag) {
      case "FooError":
        return "Recovering from FooError"
      case "BarError":
        return "Recovering from BarError"
    }
  }
  return successOrFailure.right
})
```

</Tab>
</Tabs>

<Warning>
  It is important to ensure that all the error types used with `catchTags` have
  a `readonly _tag` discriminant field. This field is required for the matching
  and handling of specific error tags.
</Warning>

## Modifying

Sometimes, instead of handling an error directly, you may need to transform or modify it in some way.
This can involve adding extra information to the error or changing its type altogether.
In such cases, you can use the `mapError` function.

<Tabs>
<Tab>

```ts {3-9}
// Effect<never, Error, string>
const modified = program.pipe(
  Effect.mapError((error) => {
    if (error._tag === "FooError") {
      return new Error("Something went wrong with Foo")
    } else {
      return new Error("Something went wrong with Bar")
    }
  })
)
```

In the code snippet above, `mapError` is applied to the `Effect` computation.
It allows us to transform the error produced by the computation while keeping the success value unchanged.
The provided error transformation function takes the original error as an input and returns a new error.

</Tab>
<Tab>

```ts {8-13}
import * as Either from "@effect/data/Either"

// Effect<never, Error, string>
const modified = Effect.gen(function* (_) {
  const successOrFailure = yield* _(Effect.either(program))
  if (Either.isLeft(successOrFailure)) {
    const error = successOrFailure.left
    switch (error._tag) {
      case "FooError":
        return yield* _(Effect.fail(new Error("Something went wrong with Foo")))
      case "BarError":
        return yield* _(Effect.fail(new Error("Something went wrong with Bar")))
    }
  }
  return successOrFailure.right
})
```

</Tab>
</Tabs>

We can observe that the type in the error channel of our `program` has changed from `FooError | BarError` to `Error`.

```ts /Error/
Effect<never, Error, string>
```

## Short-Circuiting

When working with APIs like `Effect.map`, `Effect.flatMap`, and `Effect.all`, it's important to understand how they handle errors.
These APIs are designed to **short-circuit the execution** upon encountering the **first error**.

What does this mean for you as a developer? Well, let's say you have a chain of operations or a collection of effects to be executed in sequence. If any error occurs during the execution of one of these effects, the remaining computations will be skipped, and the error will be propagated to the final result.

In simpler terms, the short-circuiting behavior ensures that if something goes wrong at any step of your program, it won't waste time executing unnecessary computations. Instead, it will immediately stop and return the error to let you know that something went wrong.

<Tabs>
  <Tab>

```ts
import * as Effect from "@effect/io/Effect"

const operation1 = Effect.sync(() => console.log("operation1"))
const operation2 = Effect.fail(new Error("Something went wrong!"))
const operation3 = Effect.sync(() => console.log("operation3"))

const result = Effect.runSyncExit(
  operation1.pipe(
    Effect.flatMap(() => operation2),
    Effect.flatMap(() => operation3) // This computation won't be executed because the previous one fails
  )
)

console.log(result)

/*
operation1
Failure("Something went wrong!")
*/
```

</Tab>
<Tab>

```ts
import * as Effect from "@effect/io/Effect"

const operation1 = Effect.sync(() => console.log("operation1"))
const operation2 = Effect.fail(new Error("Something went wrong!"))
const operation3 = Effect.sync(() => console.log("operation3"))

const result = Effect.runSyncExit(
  Effect.gen(function* (_) {
    yield* _(operation1)
    yield* _(operation2)
    yield* _(operation3) // This computation won't be executed because the previous one fails
  })
)

console.log(result)

/*
operation1
Failure("Something went wrong!")
*/
```

</Tab>
</Tabs>

This code snippet demonstrates the short-circuiting behavior when an error occurs.
Each operation depends on the successful execution of the previous one.
If any error occurs, the execution is short-circuited, and the error is propagated.
In this specific example, `operation3` is never executed because an error occurs in `operation2`.
