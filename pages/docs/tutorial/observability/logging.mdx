import { Tabs, Tab } from "@/components/Code"

# Logging

Effect provides a set of built-in utilities for logging. Let's explore the main ones.

## logInfo

By default, `INFO` messages are printed.

<Tabs>
<Tab>

```ts
import { pipe } from "@effect/data/Function"
import * as Effect from "@effect/io/Effect"
import * as Duration from "@effect/data/Duration"

// Effect<never, never, void>
const task1 = Effect.sleep(Duration.seconds(2))

// Effect<never, never, void>
const task2 = Effect.sleep(Duration.seconds(1))

// Effect<never, never, void>
const program = pipe(
  Effect.logInfo("start"),
  Effect.flatMap(() => task1),
  Effect.flatMap(() => task2),
  Effect.flatMap(() => Effect.logInfo("done"))
)

Effect.runPromise(program)
/*
...more infos... level=INFO message=start
... 3 seconds ...
...more infos... level=INFO message=done
*/
```

</Tab>
<Tab>

```ts
import * as Effect from "@effect/io/Effect"
import * as Duration from "@effect/data/Duration"

// Effect<never, never, void>
const task1 = Effect.sleep(Duration.seconds(2))

// Effect<never, never, void>
const task2 = Effect.sleep(Duration.seconds(1))

// Effect<never, never, void>
const program = Effect.gen(function* (_) {
  yield* _(Effect.logInfo("start"))
  yield* _(task1)
  yield* _(task2)
  yield* _(Effect.logInfo("done"))
})

Effect.runPromise(program)
/*
...more infos... level=INFO message=start
... 3 seconds ...
...more infos... level=INFO message=done
*/
```

</Tab>
</Tabs>

In the above example, the `Effect.logInfo` function is used to log an `INFO` message with the content `"start"` and `"done"`. These messages will be printed during the execution of the program.

## logDebug

By default, `DEBUG` messages are **not** printed.

However, you can configure the default logger to enable them using `Logger.withMinimumLogLevel` and setting the minimum log level to `LoggerLevel.Debug`.

Here's an example that demonstrates how to enable `DEBUG` messages for a specific task (`task1`):

<Tabs>
<Tab>

```ts {11}
import { pipe } from "@effect/data/Function"
import * as Effect from "@effect/io/Effect"
import * as Duration from "@effect/data/Duration"
import * as Logger from "@effect/io/Logger"
import * as LoggerLevel from "@effect/io/Logger/Level"

// Effect<never, never, void>
const task1 = pipe(
  Effect.sleep(Duration.seconds(2)),
  Effect.flatMap(() => Effect.logDebug("task1 done")),
  Logger.withMinimumLogLevel(LoggerLevel.Debug)
)

// Effect<never, never, void>
const task2 = pipe(
  Effect.sleep(Duration.seconds(1)),
  Effect.flatMap(() => Effect.logDebug("task2 done"))
)

// Effect<never, never, void>
const program = pipe(
  Effect.logInfo("start"),
  Effect.flatMap(() => task1),
  Effect.flatMap(() => task2),
  Effect.flatMap(() => Effect.logInfo("done"))
)

Effect.runPromise(program)
/*
...more infos... level=INFO message=start
... 2 seconds ...
...more infos... level=DEBUG message="task1 done"
... 1 second ...
...more infos... level=INFO message=done
*/
```

</Tab>
<Tab>

```ts {13}
import { pipe } from "@effect/data/Function"
import * as Effect from "@effect/io/Effect"
import * as Duration from "@effect/data/Duration"
import * as Logger from "@effect/io/Logger"
import * as LoggerLevel from "@effect/io/Logger/Level"

// Effect<never, never, void>
const task1 = pipe(
  Effect.gen(function* (_) {
    yield* _(Effect.sleep(Duration.seconds(2)))
    yield* _(Effect.logDebug("task1 done"))
  }),
  Logger.withMinimumLogLevel(LoggerLevel.Debug)
)

// Effect<never, never, void>
const task2 = Effect.gen(function* (_) {
  yield* _(Effect.sleep(Duration.seconds(1)))
  yield* _(Effect.logDebug("task2 done"))
})

// Effect<never, never, void>
const program = Effect.gen(function* (_) {
  yield* _(Effect.logInfo("start"))
  yield* _(task1)
  yield* _(task2)
  yield* _(Effect.logInfo("done"))
})

Effect.runPromise(program)
/*
...more infos... level=INFO message=start
... 2 seconds ...
...more infos... level=DEBUG message="task1 done"
... 1 second ...
...more infos... level=INFO message=done
*/
```

</Tab>
</Tabs>

In the above example, we enable `DEBUG` messages specifically for `task1` by using the `Logger.withMinimumLogLevel` function.

By using `Logger.withMinimumLogLevel(effect, level){:ts}`, you have the flexibility to selectively enable different log levels for specific effects in your program. This allows you to control the level of detail in your logs and focus on the information that is most relevant to your debugging and troubleshooting needs.
